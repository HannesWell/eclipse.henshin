<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<style type="text/css">
p.in { background-color: rgb(255, 255, 230);
		border: 1px solid rgb(230, 230, 150);
		margin: 2px;
		padding: 2px; }
h2 { border-top: 1px dotted rgb(230, 230, 230); }
pre { border: 1px solid rgb(128, 128, 128); 
		margin: 2px;
		padding: 2px; }
</style>
<title>Writing tests with the henshin test framework</title>
</head>
<body>
<h1>Writing tests with the henshin test framework</h1>

<p class="in">The henshin test framework allows for easy test development by extending the HenshinTest class which features some predefined methods and variables. Please note that the HenshinTest class should only be used for testing and writing tests.<br />
In this document, variables will look like <em>this</em> and methods will look like <strong>this</strong></p>

<h2>Pre-defined Variables</h2>
<p class="in">Several variables will be initialized appropriately when loading rules or models. These variables can be used in the tests for extra convenience. Loaders will, as an intended side-effect, overwrite at least some of these variables.</p>

<p><em>htTransformationSystem</em> -- the current TransformationSystem. Will be set up automatically when loading a henshin file (cf. <strong>init</strong>)</p>

<p><em>htEngine</em>, <em>htEmfGraph</em> -- the current EmfEngine and corresponding EmfGraph. Will be set up automatically when loading a model.</p>

<p><em>htRule</em>, <em>htRuleApp</em> -- the currently loaded Rule and RuleApplication. When loading a Rule (by calling loadRule), a RuleApplication htRuleApplication will automatically be created using the current EmfEngine (<em>htEngine</em>).</p>

<p><em>htTransUnit</em>, <em>htUnitApp</em> -- the currently loaded TransformationUnit and UnitApplication. When loading a TransformationUnit (by calling loadTu), a UnitApplication htUnitApp will automatically be created using the current EmfEngine (<em>htEngine</em>).
</p>

<p><em>graphBasePath</em>, <em>graphFileExtension</em> -- Usually, tests are run on several models. These variables can be used to define a common directory and file extension for the model files, so they can be loaded more easily by just providing the model's name in the actual loader. <em>graphBasePath</em> will be prepended to the file name, and <em>graphFileExtension</em> will be appended. Please note that these variables are used for model graphs, not for henshin files. These variables should be initialized by using <strong>setModelGraphProperties(String graphPath, String fileExtension)</strong></p>

<h2>Methods</h2>

<h3>Initializing</h3>
<p class="in">The <strong>init</strong> method is used for initializing tests. This method will load a henshin file, create a TransformationSystem and (optionally) load a model and set up the EmfEngine. It is recommended to call the init method at the start of the JUnit <strong>setUp()</strong> method.<br />
List of init methods:</p>
<p><strong>init(String henshinFile)</strong> -- will set up the TransformationSystem. This method will not load a model nor set up the EmfEngine, which has to be done manually. Most methods (especially loadRule and loadTu) rely on a model being loaded.</p>
<p><strong>init(String henshinFile, String modelFile, String modelFileExt)</strong> -- will set up the TransformationSystem and load a model, thus setting up the EmfEngine.</p>
<p><strong>init(String henshinFile, String modelFile, String modelFileExt, TransformationOptions options)</strong> -- will set up the TransformationSystem with the specified TransformationOptions, and load a model, thus setting up the EmfEngine.</p>
<p><strong>init(String modelFile, String modelFileExt)</strong> -- will load a model, thus setting up the EmfEngine. Attention: This method will not set up a TransformationSystem, so <em>htTransformationSystem</em> will need to be set manually after loading a henshin file. Otherwise, methods relying on htTransformationSystem being set (e.g. loadRule, loadTu) will not work.</p>
<p><strong>init(String modelFile, String modelFileExt, TransformationOptions options)</strong> -- will load a model, thus setting up the EmfEngine with the specified TransformationOptions. Attention: This method will not set up a TransformationSystem, so <em>htTransformationSystem</em> will need to be set manually after loading a henshin file. Otherwise, methods relying on htTransformationSystem being set (e.g. loadRule, loadTu) will not work.</p>


<p><strong>setModelGraphProperties(String graphPath, String fileExtension)</strong> -- will set up the graph base path and graph file extension, i.e. the directory in which all graphs for the current range of tests will be found and their file extension. This method will just assign graphPath to <em>graphBasePath</em> and fileExtension to <em>graphFileExtension</em>.</p>

<h3>Loading Rules and TransformationUnits</h3>
<p class="in">A single test case will usually test a specific henshin Rule or TransformationUnit, so setting up Rules to be applied is a very common task in testing. There are several methods which will allow to quickly set up Rules and TransformationUnits for execution. These are intended to be used just before application/execution, as they overwrite <em>htRule</em>, <em>htRuleApp</em>, <em>htTransUnit</em>, and <em>htUnitApp</em>.
</p>

<p><strong>loadRule(String ruleName)</strong> -- Loads a Rule from the previously loaded henshin file. The loaded Rule will be assigned to <em>htRule</em>, and a RuleApplication will be created and assigned to <em>htRuleApp</em>.</p>
<p><strong>loadRule(String ruleName, String paramName, String paramValue)</strong> -- Loads a Rule from the previously loaded henshin file. The loaded Rule will be assigned to <em>htRule</em>, and a RuleApplication will be created and assigned to <em>htRuleApp</em>. In the RuleApplication, the value of the Parameter specified in paramName will be set to paramValue.</p>
<p><strong>loadRule(String ruleName, Map&lt;String, Object&gt; paramMappings)</strong> -- Loads a Rule from the previously loaded henshin file. The loaded Rule will be assigned to <em>htRule</em>, and a RuleApplication will be created and assigned to <em>htRuleApp</em>. In the RuleApplication, the Parameters specified in the Map between Parameter Names and Parameter Values will be set to their specified values.</p>
	
	
<p><strong>loadTu(String unitName)</strong> -- Loads a TransformationUniot from the previously loaded henshin file. The loaded Transformation Unit will be assigned to <em>htTransUnit</em>, and a UnitApplication will be created and assigned to <em>htUnitApp</em>.</p>
<p><strong>loadTu(String unitName, String paramName, Object paramValue)</strong> -- Loads a TransformationUnit from the previously loaded henshin file. The loaded Transformation Unit will be assigned to <em>htTransUnit</em>, and a UnitApplication will be created and assigned to <em>htUnitApp</em>. In the UnitApplication, the value of the Parameter specified in paramName will be set to paramValue.</p>
<p><strong>loadTu(String unitName, Map&lt;String, Object&gt; paramMappings)</strong> -- Loads a TransformationUnit from the previously loaded henshin file. The loaded Transformation Unit will be assigned to <em>htTransUnit</em>, and a UnitApplication will be created and assigned to <em>htUnitApp</em>. In the UnitApplication, the Parameters specified in the Map between Parameter Names and Parameter Values will be set to their specified values.</p>
	

<h3>Loading models (graphs)</h3>	
<p class="in">There are several methods for loading models (graphs) and setting up the transformation engine required to actually run transformations on the graph. For tests, usually only one model needs to be loaded and transformed per test, so the henshin test framework will automatically set up and provide  direct access to the EmfGraph (<em>htEmfGraph</em>) and EmfEngine (<em>htEngine</em>).</p>

<p><strong>loadGraph(EmfGraph graph)</strong> -- Loads an EmfGraph and sets up a new EmfEngine for executing transformations on the graph. The EmfGraph will be assigned to <em>htEmfGraph</em>, and the new EmfEngine will be assigned to <em>htEngine</em>.
</p>
<p><strong>loadEmbeddedGraph(String embeddedGraphName)</strong> -- Loads a graph from the current transformation system. This method should not be used and might be removed in future versions.</p>
<p><strong>loadGraph(String graphName)</strong> -- Loads a graph from a file. <em>graphBasePath</em> will be prepended to graphName, and <em>graphFileExtension</em> will be appended, so the graph loaded will actually be <span style="border: 1px solid black"><span style="background: rgb(230, 230, 250)">graphBasePath</span><span style="background: rgb(250, 230, 230)">graphName</span>.<span style="background: rgb(230, 250, 230)">graphFileExtension</span></span><br />
The loaded graph will be assigned to <em>htEmfGraph</em>, and a new EmfEngine <em>htEngine</em> will be set up for executing transformations on the loaded graph.<br />
Note: When multiple graphs should be loaded, e.g. as arguments for methods such as <strong>assertTransformsGraph(Rule r, EmfEngine engine, EmfGraph graph2, double matchSimilarityThreshold)</strong>, it is recommended to use <strong>HenshinLoaders.loadGraph(URI graphURI)</strong> in combination with <strong>URI getGraphURI(String graphName)</strong> (see example below).
</p>
<p><strong>URI getGraphURI(String graphName)</strong> -- Returns the URI of a graph. <em>graphBasePath</em> will be prepended to graphName, and <em>graphFileExtension</em> will be appended, so the URI returned will actually be <span style="border: 1px solid black"><span style="background: rgb(230, 230, 250)">graphBasePath</span><span style="background: rgb(250, 230, 230)">graphName</span>.<span style="background: rgb(230, 250, 230)">graphFileExtension</span></span>.<br />
This method can be used in combination with <strong>HenshinLoaders.loadGraph(URI graphURI)</strong> to load graphs without overwriting <em>htEmfGraph</em> and <em>htEngine</em>.
</p>

<h2>Usage examples</h2>
<p class="in">Here are some examples of how to use the HenshinTest class to quickly write tests. The HenshinTest class makes generous use of side effects to allow for easier and more effective test development. However, these methods should not be used in non-test code. Please refer to the test framework documentation for a description of the available assertions and helper methods.</p>

<h3>Basic test initialization</h3>
<pre>
public class CreateNodes extends HenshinTest {
	
	@Before
	public void setUp() throws Exception {
		init("basicTestRules/basicTests.henshin");
		setModelGraphProperties("basicTestModels/createNodesModels/", "testmodel");
		loadGraph("graphWithOneNode");
	}

}
</pre>
<p>This example shows some basic test initialization. For this collection of tests, several graphs will used. These graphs have been put in the directory "basicTestModels/createNodesModels/" and share the common file extension "testmodel".<br />
First, a henshin file (basicTestRules/basicTests.henshin) is loaded; this will set up the TransformationSystem. Then, the directory containing all graphs and their file extension is set up.<br />
Many tests in this class will use a certain graph (graphWithOneNode) as a starting point, so it can be loaded in the <strong>setUp()</strong> method. At the end of this method, the TransformationSystem <em>htTransformationSystem</em>, EmfGraph <em>htEmfGraph</em>, and EmfEngine <em>htEngine</em> are set up and ready to use.</p>

<h3>Basic test</h3>
<pre>
public class MatchTests extends HenshinTest {
	
	@Before
	public void setUp() throws Exception {
		init("basicTestRules/basicMatchingTests.henshin");
		setModelGraphProperties("basicTestModels/matchTestsModels/", "testmodel");
	}
	
	@Test
	public void testACMatchNoNodes() {
		/**
		 * test if no nodes are matched when using a NAC containing the Node to
		 * be matched in the Rule (match (Node) and (NOT Node))
		 */
		loadGraph("manyNodes");
		loadRule("acMatchNoNode");
		Rules.assertRuleHasNoMatch(htRuleApp);
	}
}
</pre>
<p>This example shows some basic test initialization as seen in the previous example, and a small test.<br />
The test loads a graph (manyNodes). The Rule "acMatchNoNode" from the henshin file (specified in <strong>setUp()</strong>) is loaded and a RuleApplication <em>htRuleApp</em> is automatically created. This RuleApplication can then be used directly. 
</p>

<h3>Test with graph comparison</h3>
<p>Many tests will take a graph, try to apply a transformation on it and then compare the resulting graph with a graph containing the expected result.</p>
<pre>
public class CreateNodes extends HenshinTest {
	
	@Before
	public void setUp() throws Exception {
		init("basicTestRules/basicTests.henshin");
		setModelGraphProperties("basicTestModels/createNodesModels/", "testmodel");
	}
	
	
	@Test
	public void testCreateNodeWithContainmentEdge() {
		/**
		 * Create a node (type: Node) with just a containment edge
		 */
		loadGraph("graphWithCont");
		loadRule("createNodeWithContainmentEdge");
		GraphTransformations.assertTransformsGraph(htRule, htEmfGraph,
					HenshinLoaders.loadGraph(getGraphURI("graphWithOneNode")), 0.9);
	}
}
</pre>
<p><strong>setUp()</strong> as in the other examples. In the test, a graph and a Rule are loaded, initializing the Rule <em>htRule</em> and the EmfGraph <em>htEmfGraph</em>. To assert whether the loaded Rule transforms the loaded graph into another graph ("graphWithOneNode"), this other graph (which is located in the same directory as "graphWithCont" and has the same file extension) is loaded by getting its URI and just loading it using <strong>HenshinLoaders.loadGraph(URI graphURI)</strong>.
</p>


<div style="border: 1px solid rgb(192, 168, 255); margin-top: 2cm;">Version 2011-10-18, for henshin 0.8</div>
</body>
</html>