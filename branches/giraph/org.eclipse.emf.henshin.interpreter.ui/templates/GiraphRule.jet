<%@ jet package="org.eclipse.emf.henshin.interpreter.ui.giraph" class="GiraphRuleTemplate" 
imports="java.util.* org.eclipse.emf.henshin.model.* org.eclipse.emf.henshin.interpreter.ui.giraph.GiraphUtil org.eclipse.emf.henshin.interpreter.ui.giraph.GiraphUtil.MatchingStep org.eclipse.emf.ecore.*" %>

<%

@SuppressWarnings("unchecked")
Map<String,Object> args = (Map<String,Object>) argument;

Rule rule = (Rule) args.get("rule");
String className = (String) args.get("className");

Map<ENamedElement,String> typeConstants = GiraphUtil.getTypeConstants(rule.getModule());
List<MatchingStep> matchingSteps = GiraphUtil.getMatchingSteps(rule);

%>
import org.apache.log4j.Logger;

public class <%= className %> extends BasicComputation
	<LongWritable, IntegerWritable, IntegerWritable, BytesWritable> {

<%
int value = 0;
for (ENamedElement type : typeConstants.keySet()) {
	%>
	public static final int <%= typeConstants.get(type) %> = <%= value++ %>;
	<%
}
%>
	private static Logger LOG = Logger.getLogger(<%= className %>.class);


	@Override
	public void compute(
			Vertex<LongWritable, IntegerWritable, IntegerWritable> vertex,
			Iterable<BytesWritable> matches) throws IOException {


<% 
		for (int i=0; i<matchingSteps.size(); i++) {
			MatchingStep step = matchingSteps.get(i);

%>		<%= i>0 ? "else " : "" %>if (getSuperStep()==<%= i %>) {

<% if (step.verify) { %>
			// Verify that there exists an edge:
			boolean ok = true;
<% } else { %>
			// Check whether this vertex is of type "<%= step.node.getType().getName() %>":
			boolean ok = (vertex.getValue().get()==<%= typeConstants.get(step.node.getType()) %>);
			
<% } %>
			if (ok) {
				<% if (i==0) { %>
				// Create a new partial match:
				BytesWritable match = addInt(null, vertex.getId());
				<% } else { %>
				// Extend all partial matches and forward them to the next nodes:
				for (BytesWritable match : matches) {
					match = addInt(match, vertex.getId());
				<% } 
				if (step.edge!=null) { %>
					// Send a match request to all outgoing edges of type "<%= step.edge.getType().getName() %>":
					for (Edge edge : getEdges()) {
						if (edge.getValue().get()==<%= typeConstants.get(step.edge.getType()) %>) {
							sendMessage(edge.getTargetVertexId(), match);
						}
					}
				<% } 
				if (i>0) { %>
				}
				<% } %>
			} // end if ok
			
		}

<% 
		} // end for
%>		
		// Next nodes are activated by a message, so we can stop:
		voteForHalt();		
	
	}

	private static int getInt(BytesWritable message, int index) {
		byte[] b = message.getBytes();
		int x = index*4;
		return (((int)b[x]) << 24) + 
			  ((((int)b[x+1]) & 0xFF) << 16) + 
			  ((((int)b[x+2]) & 0xFF) << 8) + 
			  (((int)b[x+3]) & 0xFF);
	}

	private static BytesWritable addInt(BytesWritable message, int value) {
		byte[] b = (message!=null) ? message.getBytes() : EMPTY_BYTE_ARRAY;
		b = Arrays.copyOf(b, b.length+4);
		b[b.length-4] = value >>> 24;
		b[b.length-3] = value >>> 16;
		b[b.length-2] = value >>> 8;
		b[b.length-1] = value;
		return new BytesWritable(b);
	}

	private static byte[] EMPTY_BYTE_ARRAY = new byte[0];
	
}
