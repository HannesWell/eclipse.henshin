<%@ jet package="org.eclipse.emf.henshin.interpreter.ui.giraph" class="GiraphRuleTemplate" 
imports="java.util.* org.eclipse.emf.henshin.model.* org.eclipse.emf.henshin.interpreter.ui.giraph.GiraphUtil org.eclipse.emf.henshin.interpreter.ui.giraph.GiraphUtil.MatchingStep org.eclipse.emf.ecore.*" %>

<%

@SuppressWarnings("unchecked")
Map<String,Object> args = (Map<String,Object>) argument;

Rule rule = (Rule) args.get("rule");
String className = (String) args.get("className");

Map<ENamedElement,String> typeConstants = GiraphUtil.getTypeConstants(rule.getModule());
List<MatchingStep> matchingSteps = GiraphUtil.getMatchingSteps(rule);

%>
import org.apache.giraph.graph.*;
import org.apache.hadoop.io.*;
import org.apache.log4j.Logger;

public class <%= className %> extends BasicComputation
	<LongWritable, IntegerWritable, IntegerWritable, BytesWritable> {

<%
int value = 0;
for (ENamedElement type : typeConstants.keySet()) {
	%>
	public static final int <%= typeConstants.get(type) %> = <%= value++ %>;
	<%
}
%>
	private static Logger LOG = Logger.getLogger(<%= className %>.class);


	@Override
	public void compute(
			Vertex<LongWritable, IntegerWritable, IntegerWritable> vertex,
			Iterable<BytesWritable> matches) throws IOException {

		int superStep = getSuperStep();
		
<% 
		for (int i=0; i<matchingSteps.size(); i++) {
			MatchingStep step = matchingSteps.get(i);

%>		<%= i>0 ? "else " : "" %>if (superStep==<%= i %>) {

<% 			if (step.verifyEdgeTo>=0) { %>
			// Node <%= GiraphUtil.getNodeName(step.edge.getSource()) %>: check for edge to match of <%= GiraphUtil.getNodeName(step.edge.getTarget()) %> of type "<%= step.edge.getType().getName() %>":
			Iterator<BytesWritable> it = matches.iterator();
			while (filteredMatches.hasNext()) {
				BytesWritable match = it.next();
				int target = getInt(match, <%= step.verifyEdgeTo %>);
				for (Edge edge : getEdges()) {
					if (edge.getValue().get()==<%= typeConstants.get(step.edge.getType()) %> && edge.getTargetVertexId()==target) {
						target = -1;
						break; // Ok, we found it.
					}
				}
				// If no edge found, remove this partial match:
				if (target>=0) {
					it.remove();
				}
			}
			
<%			} else { %>
			// Matching node <%= GiraphUtil.getNodeName(step.node) %>. Type must be "<%= step.node.getType().getName() %>":
			boolean ok = (vertex.getValue().get()==<%= typeConstants.get(step.node.getType()) %>);
			if (ok) {
				<% if (i==0) { %>
				// Create a new partial match:
				BytesWritable match = addInt(null, vertex.getId());
				<% } else { %>
				// Extend all partial matches:
				for (BytesWritable match : matches) {
					match = addInt(match, vertex.getId());
				<% } 
				if (step.edge!=null) { %>
					// Send a match request to all outgoing edges of type "<%= step.edge.getType().getName() %>":
					for (Edge edge : getEdges()) {
						if (edge.getValue().get()==<%= typeConstants.get(step.edge.getType()) %>) {
							sendMessage(edge.getTargetVertexId(), match);
						}
					}
				<% } else if (step.sendBackTo>=0) { %>
					// Send the message back to matches of node <%= GiraphUtil.getNodeName(matchingSteps.get(step.sendBackTo).node) %>:
					for (ByteWritable match : matches) {
						sendMessage(getInt(match, <%= step.sendBackTo %>), match);
					}
				<% }
				if (i>0) { %>
				}
				<% } %>
			} // end if ok
			
<%			}
			if (i==matchingSteps.size()-1) { %>
			LOG.debug("Found " + matches.size() + " for rule <%= className %>");
			
<%          } %>						
		}

<% 
		} // end for
%>		
		// Next nodes are activated by a message, so we can sleep:
		voteForHalt();
	
	}

	private static int getInt(BytesWritable message, int index) {
		byte[] b = message.getBytes();
		int x = index*4;
		return (((int)b[x]) << 24) + 
			  ((((int)b[x+1]) & 0xFF) << 16) + 
			  ((((int)b[x+2]) & 0xFF) << 8) + 
			  (((int)b[x+3]) & 0xFF);
	}

	private static BytesWritable addInt(BytesWritable message, int value) {
		byte[] b = (message!=null) ? message.getBytes() : EMPTY_BYTE_ARRAY;
		b = Arrays.copyOf(b, b.length+4);
		b[b.length-4] = value >>> 24;
		b[b.length-3] = value >>> 16;
		b[b.length-2] = value >>> 8;
		b[b.length-1] = value;
		return new BytesWritable(b);
	}

	private static byte[] EMPTY_BYTE_ARRAY = new byte[0];
	
}
