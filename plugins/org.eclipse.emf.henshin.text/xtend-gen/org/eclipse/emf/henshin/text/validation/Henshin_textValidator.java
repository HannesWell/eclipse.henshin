/**
 * generated by Xtext 2.10.0
 */
package org.eclipse.emf.henshin.text.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.henshin.text.henshin_text.AndExpression;
import org.eclipse.emf.henshin.text.henshin_text.Attribute;
import org.eclipse.emf.henshin.text.henshin_text.Call;
import org.eclipse.emf.henshin.text.henshin_text.ComparisonExpression;
import org.eclipse.emf.henshin.text.henshin_text.ConditionEdge;
import org.eclipse.emf.henshin.text.henshin_text.ConditionGraph;
import org.eclipse.emf.henshin.text.henshin_text.ConditionGraphElements;
import org.eclipse.emf.henshin.text.henshin_text.ConditionGraphRef;
import org.eclipse.emf.henshin.text.henshin_text.ConditionNode;
import org.eclipse.emf.henshin.text.henshin_text.ConditionNodeTypes;
import org.eclipse.emf.henshin.text.henshin_text.ConditionReuseNode;
import org.eclipse.emf.henshin.text.henshin_text.ConditionalUnit;
import org.eclipse.emf.henshin.text.henshin_text.EPackageImport;
import org.eclipse.emf.henshin.text.henshin_text.Edge;
import org.eclipse.emf.henshin.text.henshin_text.Edges;
import org.eclipse.emf.henshin.text.henshin_text.EqualityExpression;
import org.eclipse.emf.henshin.text.henshin_text.Expression;
import org.eclipse.emf.henshin.text.henshin_text.Formula;
import org.eclipse.emf.henshin.text.henshin_text.Graph;
import org.eclipse.emf.henshin.text.henshin_text.GraphElements;
import org.eclipse.emf.henshin.text.henshin_text.Henshin_textPackage;
import org.eclipse.emf.henshin.text.henshin_text.IndependentUnit;
import org.eclipse.emf.henshin.text.henshin_text.IntegerValue;
import org.eclipse.emf.henshin.text.henshin_text.IteratedUnit;
import org.eclipse.emf.henshin.text.henshin_text.JavaAttributeValue;
import org.eclipse.emf.henshin.text.henshin_text.JavaClassValue;
import org.eclipse.emf.henshin.text.henshin_text.JavaImport;
import org.eclipse.emf.henshin.text.henshin_text.Logic;
import org.eclipse.emf.henshin.text.henshin_text.LoopUnit;
import org.eclipse.emf.henshin.text.henshin_text.Match;
import org.eclipse.emf.henshin.text.henshin_text.MinusExpression;
import org.eclipse.emf.henshin.text.henshin_text.Model;
import org.eclipse.emf.henshin.text.henshin_text.ModelElement;
import org.eclipse.emf.henshin.text.henshin_text.MulOrDivExpression;
import org.eclipse.emf.henshin.text.henshin_text.MultiRule;
import org.eclipse.emf.henshin.text.henshin_text.MultiRuleReuseNode;
import org.eclipse.emf.henshin.text.henshin_text.Node;
import org.eclipse.emf.henshin.text.henshin_text.NotExpression;
import org.eclipse.emf.henshin.text.henshin_text.NumberValue;
import org.eclipse.emf.henshin.text.henshin_text.OrExpression;
import org.eclipse.emf.henshin.text.henshin_text.Parameter;
import org.eclipse.emf.henshin.text.henshin_text.ParameterKind;
import org.eclipse.emf.henshin.text.henshin_text.ParameterType;
import org.eclipse.emf.henshin.text.henshin_text.ParameterValue;
import org.eclipse.emf.henshin.text.henshin_text.PlusExpression;
import org.eclipse.emf.henshin.text.henshin_text.PriorityUnit;
import org.eclipse.emf.henshin.text.henshin_text.Rule;
import org.eclipse.emf.henshin.text.henshin_text.RuleElement;
import org.eclipse.emf.henshin.text.henshin_text.RuleNodeTypes;
import org.eclipse.emf.henshin.text.henshin_text.Type;
import org.eclipse.emf.henshin.text.henshin_text.Unit;
import org.eclipse.emf.henshin.text.henshin_text.UnitElement;
import org.eclipse.emf.henshin.text.henshin_text.impl.ANDImpl;
import org.eclipse.emf.henshin.text.henshin_text.impl.CheckDanglingImpl;
import org.eclipse.emf.henshin.text.henshin_text.impl.ConditionsImpl;
import org.eclipse.emf.henshin.text.henshin_text.impl.GraphImpl;
import org.eclipse.emf.henshin.text.henshin_text.impl.InjectiveMatchingImpl;
import org.eclipse.emf.henshin.text.henshin_text.impl.JavaImportImpl;
import org.eclipse.emf.henshin.text.henshin_text.impl.NotImpl;
import org.eclipse.emf.henshin.text.henshin_text.impl.ORorXORImpl;
import org.eclipse.emf.henshin.text.henshin_text.impl.RollbackImpl;
import org.eclipse.emf.henshin.text.henshin_text.impl.StrictImpl;
import org.eclipse.emf.henshin.text.typesystem.Henshin_textType;
import org.eclipse.emf.henshin.text.typesystem.Henshin_textTypeProvider;
import org.eclipse.emf.henshin.text.validation.AbstractHenshin_textValidator;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class Henshin_textValidator extends AbstractHenshin_textValidator {
  @Inject
  @Extension
  private Henshin_textTypeProvider _henshin_textTypeProvider;
  
  /**
   * Check that the number and type of parameters match in a unit or rule call
   * This ignores VAR variables in the to-be-called unit / rule (call.elementCall) as they denote local variables
   * 
   * @param call to-be-checked call
   */
  @Check
  public void checkCallParameter(final Call call) {
    ModelElement _elementCall = call.getElementCall();
    EList<Parameter> _parameters = _elementCall.getParameters();
    final Function1<Parameter, Boolean> _function = (Parameter it) -> {
      ParameterKind _kind = it.getKind();
      return Boolean.valueOf((!Objects.equal(_kind, ParameterKind.VAR)));
    };
    Iterable<Parameter> _filter = IterableExtensions.<Parameter>filter(_parameters, _function);
    int _size = IterableExtensions.size(_filter);
    EList<Parameter> _parameters_1 = call.getParameters();
    int _size_1 = _parameters_1.size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      EReference _call_ElementCall = Henshin_textPackage.eINSTANCE.getCall_ElementCall();
      this.error("Bad Parameter Count.\'", _call_ElementCall);
    } else {
      for (int i = 0; (i < IterableExtensions.size(IterableExtensions.<Parameter>filter(call.getElementCall().getParameters(), ((Function1<Parameter, Boolean>) (Parameter it) -> {
        ParameterKind _kind = it.getKind();
        return Boolean.valueOf((!Objects.equal(_kind, ParameterKind.VAR)));
      })))); i++) {
        {
          ModelElement _elementCall_1 = call.getElementCall();
          EList<Parameter> _parameters_2 = _elementCall_1.getParameters();
          final Parameter param = _parameters_2.get(i);
          ParameterType _type = param.getType();
          Henshin_textType _typeFor = this._henshin_textTypeProvider.typeFor(_type);
          EList<Parameter> _parameters_3 = call.getParameters();
          Parameter _get = _parameters_3.get(i);
          ParameterType _type_1 = _get.getType();
          Henshin_textType _typeFor_1 = this._henshin_textTypeProvider.typeFor(_type_1);
          boolean _notEquals_1 = (!Objects.equal(_typeFor, _typeFor_1));
          if (_notEquals_1) {
            ParameterType _type_2 = param.getType();
            Henshin_textType _typeFor_2 = this._henshin_textTypeProvider.typeFor(_type_2);
            String _string = _typeFor_2.toString();
            String _plus = ("Call expected " + _string);
            String _plus_1 = (_plus + " type, but was ");
            EList<Parameter> _parameters_4 = call.getParameters();
            Parameter _get_1 = _parameters_4.get(i);
            ParameterType _type_3 = _get_1.getType();
            Henshin_textType _typeFor_3 = this._henshin_textTypeProvider.typeFor(_type_3);
            String _string_1 = _typeFor_3.toString();
            String _plus_2 = (_plus_1 + _string_1);
            String _plus_3 = (_plus_2 + ".\'");
            EReference _call_Parameters = Henshin_textPackage.eINSTANCE.getCall_Parameters();
            this.error(_plus_3, call, _call_Parameters);
          }
        }
      }
    }
  }
  
  /**
   * Warning if a parameter has the parameter kind UNKNOWN which is deprecated.
   * 
   * @param param to be checked parameter
   */
  @Check
  public void checkParameterKind(final Parameter param) {
    ParameterKind _kind = param.getKind();
    boolean _equals = Objects.equal(_kind, ParameterKind.UNKNOWN);
    if (_equals) {
      String _name = param.getName();
      String _plus = ("Parameter " + _name);
      String _plus_1 = (_plus + " should have a parameter kind of IN, INOUT, OUR or VAR. Specifying no parameter kind is deprecated.");
      this.warning(_plus_1, param, Henshin_textPackage.Literals.PARAMETER__KIND);
    }
  }
  
  /**
   * Fehler wenn eine Kante definiert wurde, die im ecore-Modell nicht existiert
   * 
   * @param edge Zu überprüfende Kante
   */
  @Check
  public void ckeckExistingEdge(final Edge edge) {
    EClass sourceType = null;
    EClass targetType = null;
    RuleNodeTypes _source = edge.getSource();
    boolean _notEquals = (!Objects.equal(_source, null));
    if (_notEquals) {
      RuleNodeTypes _source_1 = edge.getSource();
      if ((_source_1 instanceof Node)) {
        RuleNodeTypes _source_2 = edge.getSource();
        EClass _nodetype = ((Node) _source_2).getNodetype();
        sourceType = _nodetype;
      } else {
        try {
          RuleNodeTypes _source_3 = edge.getSource();
          Node _name = ((MultiRuleReuseNode) _source_3).getName();
          EClass _nodetype_1 = _name.getNodetype();
          sourceType = _nodetype_1;
        } catch (final Throwable _t) {
          if (_t instanceof ClassCastException) {
            final ClassCastException e = (ClassCastException)_t;
            sourceType = null;
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
      }
    }
    RuleNodeTypes _target = edge.getTarget();
    boolean _notEquals_1 = (!Objects.equal(_target, null));
    if (_notEquals_1) {
      RuleNodeTypes _target_1 = edge.getTarget();
      if ((_target_1 instanceof Node)) {
        RuleNodeTypes _target_2 = edge.getTarget();
        EClass _nodetype_2 = ((Node) _target_2).getNodetype();
        targetType = _nodetype_2;
      } else {
        try {
          RuleNodeTypes _target_3 = edge.getTarget();
          Node _name_1 = ((MultiRuleReuseNode) _target_3).getName();
          EClass _nodetype_3 = _name_1.getNodetype();
          targetType = _nodetype_3;
        } catch (final Throwable _t_1) {
          if (_t_1 instanceof ClassCastException) {
            final ClassCastException e_1 = (ClassCastException)_t_1;
            targetType = null;
          } else {
            throw Exceptions.sneakyThrow(_t_1);
          }
        }
      }
    }
    if (((!Objects.equal(sourceType, null)) && (!Objects.equal(targetType, null)))) {
      boolean wrongType = true;
      EClass referenceType = null;
      EList<EReference> _eAllReferences = sourceType.getEAllReferences();
      for (final EReference reference : _eAllReferences) {
        EReference _type = edge.getType();
        String _name_2 = _type.getName();
        String _name_3 = reference.getName();
        boolean _equals = Objects.equal(_name_2, _name_3);
        if (_equals) {
          wrongType = false;
          EClass _eReferenceType = reference.getEReferenceType();
          referenceType = _eReferenceType;
        }
      }
      if (wrongType) {
        EReference _type_1 = edge.getType();
        String _name_4 = _type_1.getName();
        String _plus = ("Edgetype " + _name_4);
        String _plus_1 = (_plus + " does not exist.\'");
        EReference _edge_Type = Henshin_textPackage.eINSTANCE.getEdge_Type();
        this.error(_plus_1, edge, _edge_Type);
      }
      boolean _notEquals_2 = (!Objects.equal(referenceType, targetType));
      if (_notEquals_2) {
        String _name_5 = sourceType.getName();
        String _plus_2 = ("Edge " + _name_5);
        String _plus_3 = (_plus_2 + "->");
        String _name_6 = targetType.getName();
        String _plus_4 = (_plus_3 + _name_6);
        String _plus_5 = (_plus_4 + ":");
        EReference _type_2 = edge.getType();
        String _name_7 = _type_2.getName();
        String _plus_6 = (_plus_5 + _name_7);
        String _plus_7 = (_plus_6 + " does not exist.\'");
        EReference _edge_Type_1 = Henshin_textPackage.eINSTANCE.getEdge_Type();
        this.error(_plus_7, edge, _edge_Type_1);
      }
    }
  }
  
  /**
   * Fehler wenn ein Knotentyp verwendet wurde, der nicht importiert wurde
   * 
   * @param node Zu überprüfender Knoten
   */
  @Check
  public void checkNodeType(final Node node) {
    boolean isImported = false;
    List<EPackageImport> _ePackageImports = this.getEPackageImports(node);
    for (final EPackageImport ePackage : _ePackageImports) {
      EPackage _ref = ePackage.getRef();
      EList<EClassifier> _eClassifiers = _ref.getEClassifiers();
      EClass _nodetype = node.getNodetype();
      boolean _contains = _eClassifiers.contains(_nodetype);
      if (_contains) {
        isImported = true;
      }
    }
    if ((!isImported)) {
      EClass _nodetype_1 = node.getNodetype();
      String _name = _nodetype_1.getName();
      String _plus = ("Nodetype " + _name);
      String _plus_1 = (_plus + " is not imported.\'");
      EReference _node_Nodetype = Henshin_textPackage.eINSTANCE.getNode_Nodetype();
      this.error(_plus_1, node, _node_Nodetype);
    }
  }
  
  /**
   * Holt alle importierten EPackages anhand eines beliebigen Objekts
   */
  private List<EPackageImport> getEPackageImports(final EObject startObject) {
    List<EPackageImport> listOfEPackageImport = new ArrayList<EPackageImport>();
    EObject container = startObject.eContainer();
    while ((!(container instanceof Model))) {
      EObject _eContainer = container.eContainer();
      container = _eContainer;
    }
    if ((container instanceof Model)) {
      EList<EPackageImport> _ePackageimports = ((Model) container).getEPackageimports();
      listOfEPackageImport.addAll(_ePackageimports);
    }
    return listOfEPackageImport;
  }
  
  /**
   * Fehler wenn ein Attribut in einem Knoten definiert wurde das so nicht im ecore-Modell existiert
   * 
   * @param node Zu überprüfender Knoten
   */
  @Check
  public void checkNodeAttribute(final Node node) {
    EList<Attribute> _attribute = node.getAttribute();
    for (final Attribute attribute : _attribute) {
      {
        boolean superTypeAttribute = false;
        EClass _nodetype = node.getNodetype();
        EList<EAttribute> _eAttributes = _nodetype.getEAttributes();
        EAttribute _name = attribute.getName();
        boolean _contains = _eAttributes.contains(_name);
        boolean _not = (!_contains);
        if (_not) {
          EClass _nodetype_1 = node.getNodetype();
          EList<EClass> _eAllSuperTypes = _nodetype_1.getEAllSuperTypes();
          for (final EClass supertype : _eAllSuperTypes) {
            EList<EAttribute> _eAttributes_1 = supertype.getEAttributes();
            EAttribute _name_1 = attribute.getName();
            boolean _contains_1 = _eAttributes_1.contains(_name_1);
            if (_contains_1) {
              superTypeAttribute = true;
            }
          }
          if ((!superTypeAttribute)) {
            EClass _nodetype_2 = node.getNodetype();
            String _name_2 = _nodetype_2.getName();
            String _plus = (_name_2 + " has no attribute \'");
            EAttribute _name_3 = attribute.getName();
            String _name_4 = _name_3.getName();
            String _plus_1 = (_plus + _name_4);
            String _plus_2 = (_plus_1 + "\'.\'");
            EReference _attribute_Name = Henshin_textPackage.eINSTANCE.getAttribute_Name();
            this.error(_plus_2, attribute, _attribute_Name);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn in einem Knoten das selbe Attribut mehrfach definiert wird
   * 
   * @param node Zu überprüfender Knoten
   */
  @Check
  public void checkattributeOnlyOnce(final Node node) {
    for (int i = 0; (i < node.getAttribute().size()); i++) {
      {
        EList<Attribute> _attribute = node.getAttribute();
        Attribute attribute = _attribute.get(i);
        for (int j = (i + 1); (j < node.getAttribute().size()); j++) {
          if ((Objects.equal(attribute.getName(), node.getAttribute().get(j).getName()) && Objects.equal(attribute.getUpdate(), node.getAttribute().get(j).getUpdate()))) {
            EAttribute _name = attribute.getName();
            String _name_1 = _name.getName();
            String _plus = ("\'" + _name_1);
            String _plus_1 = (_plus + "\' can only be used once.\'");
            EList<Attribute> _attribute_1 = node.getAttribute();
            Attribute _get = _attribute_1.get(j);
            EReference _attribute_Name = Henshin_textPackage.eINSTANCE.getAttribute_Name();
            this.error(_plus_1, _get, _attribute_Name);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn der Typ eines create Knoten abstrakt ist
   * 
   * @param node Zu überprüfender Knoten
   */
  @Check
  public void checkAbstractNode(final Node node) {
    if ((node.getNodetype().isAbstract() && Objects.equal(node.getActiontype(), "create"))) {
      EReference _node_Nodetype = Henshin_textPackage.eINSTANCE.getNode_Nodetype();
      this.error("Node of abstract type cannot be created.\'", node, _node_Nodetype);
    }
  }
  
  /**
   * Fehler wenn mehrere set-Attribute für ein Match-Attribut dfiniert wurden
   * 
   * @param node Knoten dessen Attribute überprüft werden
   */
  @Check
  public void checkSetAttribute(final Node node) {
    if ((Objects.equal(node.getActiontype(), "preserve") || Objects.equal(node.getActiontype(), null))) {
      EList<Attribute> _attribute = node.getAttribute();
      for (final Attribute attribute : _attribute) {
        String _update = attribute.getUpdate();
        boolean _notEquals = (!Objects.equal(_update, null));
        if (_notEquals) {
          EList<Attribute> _attribute_1 = node.getAttribute();
          for (final Attribute checkAttribute : _attribute_1) {
            if ((((!Objects.equal(checkAttribute, attribute)) && Objects.equal(attribute.getName(), checkAttribute.getName())) && ((!Objects.equal(checkAttribute.getUpdate(), null)) || Objects.equal(checkAttribute.getActiontype(), "create")))) {
              EAttribute _attribute_Update = Henshin_textPackage.eINSTANCE.getAttribute_Update();
              this.error("Duplicate update.\'", attribute, _attribute_Update);
              EAttribute _attribute_Actiontype = Henshin_textPackage.eINSTANCE.getAttribute_Actiontype();
              this.error("Duplicate update.\'", checkAttribute, _attribute_Actiontype);
            }
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn für ein set-Attribut kein Match-Attribut definiert wurde
   * 
   * @param node Knotendessen Attribute überprüft werden
   */
  @Check
  public void checkSetandMatchAttribute(final Node node) {
    if ((Objects.equal(node.getActiontype(), "preserve") || Objects.equal(node.getActiontype(), null))) {
      EList<Attribute> _attribute = node.getAttribute();
      for (final Attribute attribute : _attribute) {
        String _update = attribute.getUpdate();
        boolean _notEquals = (!Objects.equal(_update, null));
        if (_notEquals) {
          boolean matchExist = false;
          EList<Attribute> _attribute_1 = node.getAttribute();
          for (final Attribute checkAttribute : _attribute_1) {
            if ((((!Objects.equal(checkAttribute, attribute)) && Objects.equal(attribute.getName(), checkAttribute.getName())) && (Objects.equal(checkAttribute.getActiontype(), "preserve") || (Objects.equal(checkAttribute.getActiontype(), null) && (Objects.equal(node.getActiontype(), "preserve") || Objects.equal(node.getActiontype(), null)))))) {
              matchExist = true;
            }
          }
          if ((!matchExist)) {
            EAttribute _name = attribute.getName();
            String _name_1 = _name.getName();
            String _plus = ("Preserve-attribute " + _name_1);
            String _plus_1 = (_plus + " needed.\'");
            EAttribute _attribute_Update = Henshin_textPackage.eINSTANCE.getAttribute_Update();
            this.error(_plus_1, attribute, _attribute_Update);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn der ActionType eines Attributes nicht zu dem ActionType des Knoten passt
   * 
   * @param node Zu überprüfender Knoten
   */
  @Check
  public void checkNodeAttributeAction(final Node node) {
    String _actiontype = node.getActiontype();
    boolean _equals = Objects.equal(_actiontype, "create");
    if (_equals) {
      EList<Attribute> _attribute = node.getAttribute();
      for (final Attribute attribute : _attribute) {
        {
          if (((((Objects.equal(attribute.getActiontype(), "preserve") && Objects.equal(attribute.getUpdate(), null)) || Objects.equal(attribute.getActiontype(), "delete")) || Objects.equal(attribute.getActiontype(), "forbid")) || Objects.equal(attribute.getActiontype(), "require"))) {
            String _actiontype_1 = attribute.getActiontype();
            String _plus = (_actiontype_1 + "-attributes are not allowed in ");
            String _actiontype_2 = node.getActiontype();
            String _plus_1 = (_plus + _actiontype_2);
            String _plus_2 = (_plus_1 + "-nodes.\'");
            EAttribute _attribute_Actiontype = Henshin_textPackage.eINSTANCE.getAttribute_Actiontype();
            this.error(_plus_2, attribute, _attribute_Actiontype);
          }
          String _update = attribute.getUpdate();
          boolean _notEquals = (!Objects.equal(_update, null));
          if (_notEquals) {
            String _actiontype_3 = node.getActiontype();
            String _plus_3 = ("set-attributes are not allowed in " + _actiontype_3);
            String _plus_4 = (_plus_3 + "-nodes. \'");
            EAttribute _attribute_Update = Henshin_textPackage.eINSTANCE.getAttribute_Update();
            this.error(_plus_4, attribute, _attribute_Update);
          }
        }
      }
    } else {
      String _actiontype_1 = node.getActiontype();
      boolean _equals_1 = Objects.equal(_actiontype_1, "delete");
      if (_equals_1) {
        EList<Attribute> _attribute_1 = node.getAttribute();
        for (final Attribute attribute_1 : _attribute_1) {
          {
            if (((Objects.equal(attribute_1.getActiontype(), "preserve") && Objects.equal(attribute_1.getUpdate(), null)) || Objects.equal(attribute_1.getActiontype(), "create"))) {
              String _actiontype_2 = attribute_1.getActiontype();
              String _plus = (_actiontype_2 + "-attributes are not allowed in ");
              String _actiontype_3 = node.getActiontype();
              String _plus_1 = (_plus + _actiontype_3);
              String _plus_2 = (_plus_1 + "-nodes.\'");
              EAttribute _attribute_Actiontype = Henshin_textPackage.eINSTANCE.getAttribute_Actiontype();
              this.error(_plus_2, attribute_1, _attribute_Actiontype);
            }
            String _update = attribute_1.getUpdate();
            boolean _notEquals = (!Objects.equal(_update, null));
            if (_notEquals) {
              String _actiontype_4 = node.getActiontype();
              String _plus_3 = ("set-attributes are not allowed in " + _actiontype_4);
              String _plus_4 = (_plus_3 + "-nodes.\'");
              EAttribute _attribute_Update = Henshin_textPackage.eINSTANCE.getAttribute_Update();
              this.error(_plus_4, attribute_1, _attribute_Update);
            }
          }
        }
      } else {
        String _actiontype_2 = node.getActiontype();
        boolean _equals_2 = Objects.equal(_actiontype_2, "forbid");
        if (_equals_2) {
          EList<Attribute> _attribute_2 = node.getAttribute();
          for (final Attribute attribute_2 : _attribute_2) {
            {
              if (((((Objects.equal(attribute_2.getActiontype(), "preserve") && Objects.equal(attribute_2.getUpdate(), null)) || Objects.equal(attribute_2.getActiontype(), "delete")) || Objects.equal(attribute_2.getActiontype(), "create")) || Objects.equal(attribute_2.getActiontype(), "require"))) {
                String _actiontype_3 = attribute_2.getActiontype();
                String _plus = (_actiontype_3 + "-attributes are not allowed in ");
                String _actiontype_4 = node.getActiontype();
                String _plus_1 = (_plus + _actiontype_4);
                String _plus_2 = (_plus_1 + "-nodes.\'");
                EAttribute _attribute_Actiontype = Henshin_textPackage.eINSTANCE.getAttribute_Actiontype();
                this.error(_plus_2, attribute_2, _attribute_Actiontype);
              }
              String _update = attribute_2.getUpdate();
              boolean _notEquals = (!Objects.equal(_update, null));
              if (_notEquals) {
                String _actiontype_5 = node.getActiontype();
                String _plus_3 = ("set-attributes are not allowed in " + _actiontype_5);
                String _plus_4 = (_plus_3 + "-nodes.\'");
                EAttribute _attribute_Update = Henshin_textPackage.eINSTANCE.getAttribute_Update();
                this.error(_plus_4, attribute_2, _attribute_Update);
              }
            }
          }
        } else {
          String _actiontype_3 = node.getActiontype();
          boolean _equals_3 = Objects.equal(_actiontype_3, "require");
          if (_equals_3) {
            EList<Attribute> _attribute_3 = node.getAttribute();
            for (final Attribute attribute_3 : _attribute_3) {
              {
                if (((((Objects.equal(attribute_3.getActiontype(), "preserve") && Objects.equal(attribute_3.getUpdate(), null)) || Objects.equal(attribute_3.getActiontype(), "delete")) || Objects.equal(attribute_3.getActiontype(), "create")) || Objects.equal(attribute_3.getActiontype(), "forbid"))) {
                  String _actiontype_4 = attribute_3.getActiontype();
                  String _plus = (_actiontype_4 + "-attributes are not allowed in ");
                  String _actiontype_5 = node.getActiontype();
                  String _plus_1 = (_plus + _actiontype_5);
                  String _plus_2 = (_plus_1 + "-nodes.\'");
                  EAttribute _attribute_Actiontype = Henshin_textPackage.eINSTANCE.getAttribute_Actiontype();
                  this.error(_plus_2, attribute_3, _attribute_Actiontype);
                }
                String _update = attribute_3.getUpdate();
                boolean _notEquals = (!Objects.equal(_update, null));
                if (_notEquals) {
                  String _actiontype_6 = node.getActiontype();
                  String _plus_3 = ("set-attributes are not allowed in " + _actiontype_6);
                  String _plus_4 = (_plus_3 + "-nodes.\'");
                  EAttribute _attribute_Update = Henshin_textPackage.eINSTANCE.getAttribute_Update();
                  this.error(_plus_4, attribute_3, _attribute_Update);
                }
              }
            }
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn der ActionType der Kante nicht zu dem ActionType der Knoten passt
   * 
   * @param edge Zu überprüfende Kante
   */
  @Check
  public void checkNodeEdgeAction(final Edge edge) {
    Node source = null;
    Node target = null;
    RuleNodeTypes _source = edge.getSource();
    if ((_source instanceof Node)) {
      RuleNodeTypes _source_1 = edge.getSource();
      source = ((Node) _source_1);
    } else {
      try {
        RuleNodeTypes _source_2 = edge.getSource();
        Node _name = ((MultiRuleReuseNode) _source_2).getName();
        source = _name;
      } catch (final Throwable _t) {
        if (_t instanceof ClassCastException) {
          final ClassCastException e = (ClassCastException)_t;
          target = null;
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
    }
    RuleNodeTypes _target = edge.getTarget();
    if ((_target instanceof Node)) {
      RuleNodeTypes _target_1 = edge.getTarget();
      target = ((Node) _target_1);
    } else {
      try {
        RuleNodeTypes _target_2 = edge.getTarget();
        Node _name_1 = ((MultiRuleReuseNode) _target_2).getName();
        target = _name_1;
      } catch (final Throwable _t_1) {
        if (_t_1 instanceof ClassCastException) {
          final ClassCastException e_1 = (ClassCastException)_t_1;
          target = null;
        } else {
          throw Exceptions.sneakyThrow(_t_1);
        }
      }
    }
    if (((!Objects.equal(target, null)) && (!Objects.equal(source, null)))) {
      String edgetype = edge.getActiontype();
      boolean _equals = Objects.equal(edgetype, null);
      if (_equals) {
        edgetype = "preserve";
      }
      String sourcetype = source.getActiontype();
      boolean _equals_1 = Objects.equal(sourcetype, null);
      if (_equals_1) {
        sourcetype = "preserve";
      }
      String tagettype = target.getActiontype();
      boolean _equals_2 = Objects.equal(tagettype, null);
      if (_equals_2) {
        tagettype = "preserve";
      }
      if ((Objects.equal(edge.getActiontype(), "preserve") || Objects.equal(edge.getActiontype(), null))) {
        if (((Objects.equal(source.getActiontype(), "preserve") || Objects.equal(source.getActiontype(), null)) && ((!Objects.equal(target.getActiontype(), "preserve")) && (!Objects.equal(target.getActiontype(), null))))) {
          EAttribute _edge_Actiontype = Henshin_textPackage.eINSTANCE.getEdge_Actiontype();
          this.error((((((("A " + edgetype) + "-edge is not allowed between a ") + sourcetype) + "-node and a ") + tagettype) + "-node.\'"), edge, _edge_Actiontype);
        } else {
          if (((!Objects.equal(source.getActiontype(), "preserve")) && (!Objects.equal(source.getActiontype(), null)))) {
            EAttribute _edge_Actiontype_1 = Henshin_textPackage.eINSTANCE.getEdge_Actiontype();
            this.error((((((("A " + edgetype) + "-edge is not allowed between a ") + sourcetype) + "-node and a ") + tagettype) + "-node.\'"), edge, _edge_Actiontype_1);
          }
        }
      } else {
        String _actiontype = edge.getActiontype();
        boolean _equals_3 = Objects.equal(_actiontype, "create");
        if (_equals_3) {
          if ((((Objects.equal(source.getActiontype(), null) || Objects.equal(source.getActiontype(), "preserve")) || Objects.equal(source.getActiontype(), "create")) && (((!Objects.equal(target.getActiontype(), null)) && (!Objects.equal(target.getActiontype(), "preserve"))) && (!Objects.equal(target.getActiontype(), "create"))))) {
            EAttribute _edge_Actiontype_2 = Henshin_textPackage.eINSTANCE.getEdge_Actiontype();
            this.error((((((("A " + edgetype) + "-edge is not allowed between a ") + sourcetype) + "-node and a ") + tagettype) + "-node.\'"), edge, _edge_Actiontype_2);
          } else {
            if ((((!Objects.equal(source.getActiontype(), null)) && (!Objects.equal(source.getActiontype(), "preserve"))) && (!Objects.equal(source.getActiontype(), "create")))) {
              EAttribute _edge_Actiontype_3 = Henshin_textPackage.eINSTANCE.getEdge_Actiontype();
              this.error((((((("A " + edgetype) + "-edge is not allowed between a ") + sourcetype) + "-node and a ") + tagettype) + "-node.\'"), edge, _edge_Actiontype_3);
            }
          }
        } else {
          String _actiontype_1 = edge.getActiontype();
          boolean _equals_4 = Objects.equal(_actiontype_1, "delete");
          if (_equals_4) {
            if ((((Objects.equal(source.getActiontype(), null) || Objects.equal(source.getActiontype(), "preserve")) || Objects.equal(source.getActiontype(), "delete")) && (((!Objects.equal(target.getActiontype(), null)) && (!Objects.equal(target.getActiontype(), "preserve"))) && (!Objects.equal(target.getActiontype(), "delete"))))) {
              EAttribute _edge_Actiontype_4 = Henshin_textPackage.eINSTANCE.getEdge_Actiontype();
              this.error((((((("A " + edgetype) + "-edge is not allowed between a ") + sourcetype) + "-node and a ") + tagettype) + "-node.\'"), edge, _edge_Actiontype_4);
            } else {
              if ((((!Objects.equal(source.getActiontype(), null)) && (!Objects.equal(source.getActiontype(), "preserve"))) && (!Objects.equal(source.getActiontype(), "delete")))) {
                EAttribute _edge_Actiontype_5 = Henshin_textPackage.eINSTANCE.getEdge_Actiontype();
                this.error((((((("A " + edgetype) + "-edge is not allowed between a ") + sourcetype) + "-node and a ") + tagettype) + "-node.\'"), edge, _edge_Actiontype_5);
              }
            }
          } else {
            String _actiontype_2 = edge.getActiontype();
            boolean _equals_5 = Objects.equal(_actiontype_2, "forbid");
            if (_equals_5) {
              if (((((Objects.equal(source.getActiontype(), null) || Objects.equal(source.getActiontype(), "preserve")) || Objects.equal(source.getActiontype(), "delete")) || Objects.equal(source.getActiontype(), "forbid")) && (Objects.equal(target.getActiontype(), "create") || Objects.equal(target.getActiontype(), "require")))) {
                EAttribute _edge_Actiontype_6 = Henshin_textPackage.eINSTANCE.getEdge_Actiontype();
                this.error((((((("A " + edgetype) + "-edge is not allowed between a ") + sourcetype) + "-node and a ") + tagettype) + "-node.\'"), edge, _edge_Actiontype_6);
              } else {
                if ((Objects.equal(source.getActiontype(), "create") || Objects.equal(source.getActiontype(), "require"))) {
                  EAttribute _edge_Actiontype_7 = Henshin_textPackage.eINSTANCE.getEdge_Actiontype();
                  this.error((((((("A " + edgetype) + "-edge is not allowed between a ") + sourcetype) + "-node and a ") + tagettype) + "-node.\'"), edge, _edge_Actiontype_7);
                }
              }
            } else {
              String _actiontype_3 = edge.getActiontype();
              boolean _equals_6 = Objects.equal(_actiontype_3, "require");
              if (_equals_6) {
                if (((((Objects.equal(source.getActiontype(), null) || Objects.equal(source.getActiontype(), "preserve")) || Objects.equal(source.getActiontype(), "delete")) || Objects.equal(source.getActiontype(), "require")) && (Objects.equal(target.getActiontype(), "create") || Objects.equal(target.getActiontype(), "forbid")))) {
                  EAttribute _edge_Actiontype_8 = Henshin_textPackage.eINSTANCE.getEdge_Actiontype();
                  this.error((((((("A " + edgetype) + "-edge is not allowed between a ") + sourcetype) + "-node and a ") + tagettype) + "-node.\'"), edge, _edge_Actiontype_8);
                } else {
                  if ((Objects.equal(source.getActiontype(), "create") || Objects.equal(source.getActiontype(), "forbid"))) {
                    EAttribute _edge_Actiontype_9 = Henshin_textPackage.eINSTANCE.getEdge_Actiontype();
                    this.error((((((("A " + edgetype) + "-edge is not allowed between a ") + sourcetype) + "-node and a ") + tagettype) + "-node.\'"), edge, _edge_Actiontype_9);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn nicht genau ein Graph in einer Regel definiert wurde
   * 
   * @param rule Zu überprüfende Regel
   */
  @Check
  public void checkCountGraph(final Rule rule) {
    EList<RuleElement> _ruleElements = rule.getRuleElements();
    Iterable<GraphImpl> iterableOfGraphImpl = Iterables.<GraphImpl>filter(_ruleElements, GraphImpl.class);
    int _size = IterableExtensions.size(iterableOfGraphImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final GraphImpl graph : iterableOfGraphImpl) {
        String _name = rule.getName();
        String _plus = ("Multiple graphs in rule " + _name);
        String _plus_1 = (_plus + ".\'");
        this.error(_plus_1, graph, Henshin_textPackage.Literals.GRAPH__GRAPH_ELEMENTS);
      }
    } else {
      int _size_1 = IterableExtensions.size(iterableOfGraphImpl);
      boolean _equals = (_size_1 == 0);
      if (_equals) {
        String _name_1 = rule.getName();
        String _plus_2 = ("No graph in rule " + _name_1);
        String _plus_3 = (_plus_2 + ".\'");
        EReference _rule_RuleElements = Henshin_textPackage.eINSTANCE.getRule_RuleElements();
        this.error(_plus_3, rule, _rule_RuleElements);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein CheckDangling-Element in einer Regel definiert wurde
   * 
   * @param rule Zu überprüfende Regel
   */
  @Check
  public void checkCountCheckDangling(final Rule rule) {
    EList<RuleElement> _ruleElements = rule.getRuleElements();
    Iterable<CheckDanglingImpl> iterableOfCheckDanglingImpl = Iterables.<CheckDanglingImpl>filter(_ruleElements, CheckDanglingImpl.class);
    int _size = IterableExtensions.size(iterableOfCheckDanglingImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final CheckDanglingImpl checkDangling : iterableOfCheckDanglingImpl) {
        this.error("CheckDangling can only be used once.\'", checkDangling, Henshin_textPackage.Literals.CHECK_DANGLING__CHECK_DANGLING);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein InjectiveMatching-Element in einer Regel definiert wurde
   * 
   * @param rule Zu überprüfende Regel
   */
  @Check
  public void checkCountInjectiveMatching(final Rule rule) {
    EList<RuleElement> _ruleElements = rule.getRuleElements();
    Iterable<InjectiveMatchingImpl> iterableOfInjectiveMatchingImpl = Iterables.<InjectiveMatchingImpl>filter(_ruleElements, InjectiveMatchingImpl.class);
    int _size = IterableExtensions.size(iterableOfInjectiveMatchingImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final InjectiveMatchingImpl injectiveMatching : iterableOfInjectiveMatchingImpl) {
        this.error("InjectiveMatching can only be used once.\'", injectiveMatching, Henshin_textPackage.Literals.INJECTIVE_MATCHING__INJECTIVE_MATCHING);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Conditions-Element in einer Regel definiert wurde
   * 
   * @param rule Zu überprüfende Regel
   */
  @Check
  public void checkCountCondition(final Rule rule) {
    EList<RuleElement> _ruleElements = rule.getRuleElements();
    Iterable<ConditionsImpl> iterableOfConditionsImpl = Iterables.<ConditionsImpl>filter(_ruleElements, ConditionsImpl.class);
    int _size = IterableExtensions.size(iterableOfConditionsImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final ConditionsImpl conditions : iterableOfConditionsImpl) {
        this.error("Conditions can only be used once.\'", conditions, Henshin_textPackage.Literals.CONDITIONS__ATTRIBUTE_CONDITIONS);
      }
    }
  }
  
  /**
   * Fehler wenn das in eine Regel importierte Java-Package nicht existiert
   * 
   * @param rule Zu überprüfende Regel
   */
  @Check
  public void checkJavaImport(final Rule rule) {
    EList<RuleElement> _ruleElements = rule.getRuleElements();
    Iterable<JavaImportImpl> iterableOfJavaImportImpl = Iterables.<JavaImportImpl>filter(_ruleElements, JavaImportImpl.class);
    for (final JavaImportImpl javaImport : iterableOfJavaImportImpl) {
      String _packagename = javaImport.getPackagename();
      Package _package = Package.getPackage(_packagename);
      boolean _equals = Objects.equal(_package, null);
      if (_equals) {
        String _packagename_1 = javaImport.getPackagename();
        String _plus = ("Package " + _packagename_1);
        String _plus_1 = (_plus + " doesn\'t exist.\'");
        this.error(_plus_1, javaImport, Henshin_textPackage.Literals.JAVA_IMPORT__PACKAGENAME);
      }
    }
  }
  
  /**
   * Warnt wenn Java-Packages mehrfach in Regel importiert wurden
   * 
   * @param rule Zu überprüfende Regel
   */
  @Check
  public void checkMultiJavaImport(final Rule rule) {
    EList<RuleElement> _ruleElements = rule.getRuleElements();
    Iterable<JavaImportImpl> iterableOfJavaImportImpl = Iterables.<JavaImportImpl>filter(_ruleElements, JavaImportImpl.class);
    for (int i = 0; (i < IterableExtensions.size(iterableOfJavaImportImpl)); i++) {
      {
        final Iterable<JavaImportImpl> _converted_iterableOfJavaImportImpl = (Iterable<JavaImportImpl>)iterableOfJavaImportImpl;
        JavaImportImpl javaImport = ((JavaImportImpl[])Conversions.unwrapArray(_converted_iterableOfJavaImportImpl, JavaImportImpl.class))[i];
        for (int j = (i + 1); (j < IterableExtensions.size(iterableOfJavaImportImpl)); j++) {
          final Iterable<JavaImportImpl> _converted_iterableOfJavaImportImpl_1 = (Iterable<JavaImportImpl>)iterableOfJavaImportImpl;
          JavaImportImpl _get = ((JavaImportImpl[])Conversions.unwrapArray(_converted_iterableOfJavaImportImpl_1, JavaImportImpl.class))[j];
          String _packagename = _get.getPackagename();
          String _packagename_1 = javaImport.getPackagename();
          boolean _equals = Objects.equal(_packagename, _packagename_1);
          if (_equals) {
            String _packagename_2 = javaImport.getPackagename();
            String _plus = ("Package " + _packagename_2);
            String _plus_1 = (_plus + " is already imported.\'");
            final Iterable<JavaImportImpl> _converted_iterableOfJavaImportImpl_2 = (Iterable<JavaImportImpl>)iterableOfJavaImportImpl;
            EObject _get_1 = ((EObject[])Conversions.unwrapArray(_converted_iterableOfJavaImportImpl_2, EObject.class))[j];
            this.warning(_plus_1, _get_1, Henshin_textPackage.Literals.JAVA_IMPORT__PACKAGENAME);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn das in eine MultiRegel importierte Java-Package nicht existiert
   * 
   * @param rule Zu überprüfende MultiRegel
   */
  @Check
  public void checkJavaImport(final MultiRule rule) {
    EList<RuleElement> _multiruleElements = rule.getMultiruleElements();
    Iterable<JavaImportImpl> iterableOfJavaImportImpl = Iterables.<JavaImportImpl>filter(_multiruleElements, JavaImportImpl.class);
    for (final JavaImportImpl javaImport : iterableOfJavaImportImpl) {
      String _packagename = javaImport.getPackagename();
      Package _package = Package.getPackage(_packagename);
      boolean _equals = Objects.equal(_package, null);
      if (_equals) {
        String _packagename_1 = javaImport.getPackagename();
        String _plus = ("Package " + _packagename_1);
        String _plus_1 = (_plus + " doesn\'t exist.\'");
        this.error(_plus_1, javaImport, Henshin_textPackage.Literals.JAVA_IMPORT__PACKAGENAME);
      }
    }
  }
  
  /**
   * Warnt wenn Java-Packages mehrfach in MultiRegel importiert wurden
   * 
   * @param rule Zu überprüfende MultiRegel
   */
  @Check
  public void checkMultiJavaImport(final MultiRule rule) {
    EList<RuleElement> _multiruleElements = rule.getMultiruleElements();
    Iterable<JavaImportImpl> iterableOfJavaImportImpl = Iterables.<JavaImportImpl>filter(_multiruleElements, JavaImportImpl.class);
    for (int i = 0; (i < IterableExtensions.size(iterableOfJavaImportImpl)); i++) {
      {
        final Iterable<JavaImportImpl> _converted_iterableOfJavaImportImpl = (Iterable<JavaImportImpl>)iterableOfJavaImportImpl;
        JavaImportImpl javaImport = ((JavaImportImpl[])Conversions.unwrapArray(_converted_iterableOfJavaImportImpl, JavaImportImpl.class))[i];
        for (int j = (i + 1); (j < IterableExtensions.size(iterableOfJavaImportImpl)); j++) {
          final Iterable<JavaImportImpl> _converted_iterableOfJavaImportImpl_1 = (Iterable<JavaImportImpl>)iterableOfJavaImportImpl;
          JavaImportImpl _get = ((JavaImportImpl[])Conversions.unwrapArray(_converted_iterableOfJavaImportImpl_1, JavaImportImpl.class))[j];
          String _packagename = _get.getPackagename();
          String _packagename_1 = javaImport.getPackagename();
          boolean _equals = Objects.equal(_packagename, _packagename_1);
          if (_equals) {
            String _packagename_2 = javaImport.getPackagename();
            String _plus = ("Package " + _packagename_2);
            String _plus_1 = (_plus + " is already imported.\'");
            final Iterable<JavaImportImpl> _converted_iterableOfJavaImportImpl_2 = (Iterable<JavaImportImpl>)iterableOfJavaImportImpl;
            EObject _get_1 = ((EObject[])Conversions.unwrapArray(_converted_iterableOfJavaImportImpl_2, EObject.class))[j];
            this.warning(_plus_1, _get_1, Henshin_textPackage.Literals.JAVA_IMPORT__PACKAGENAME);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Conditions-Element in einer MultiRegel definiert wurde
   * 
   * @param rule Zu überprüfende MultiRegel
   */
  @Check
  public void checkCountCondition(final MultiRule rule) {
    EList<RuleElement> _multiruleElements = rule.getMultiruleElements();
    Iterable<ConditionsImpl> iterableOfConditionsImpl = Iterables.<ConditionsImpl>filter(_multiruleElements, ConditionsImpl.class);
    int _size = IterableExtensions.size(iterableOfConditionsImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final ConditionsImpl conditions : iterableOfConditionsImpl) {
        this.error("Conditions can only be used once.\'", conditions, Henshin_textPackage.Literals.CONDITIONS__ATTRIBUTE_CONDITIONS);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein InjectiveMatching-Element in einer MultiRegel definiert wurde
   * 
   * @param rule Zu überprüfende MultiRegel
   */
  @Check
  public void checkCountInjectiveMatching(final MultiRule rule) {
    EList<RuleElement> _multiruleElements = rule.getMultiruleElements();
    Iterable<InjectiveMatchingImpl> iterableOfInjectiveMatchingImpl = Iterables.<InjectiveMatchingImpl>filter(_multiruleElements, InjectiveMatchingImpl.class);
    int _size = IterableExtensions.size(iterableOfInjectiveMatchingImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final InjectiveMatchingImpl injectiveMatching : iterableOfInjectiveMatchingImpl) {
        this.error("InjectiveMatching can only be used once.\'", injectiveMatching, Henshin_textPackage.Literals.INJECTIVE_MATCHING__INJECTIVE_MATCHING);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein CheckDangling-Element in einer MultiRegel definiert wurde
   * 
   * @param rule Zu überprüfende MultiRegel
   */
  @Check
  public void checkCountCheckDangling(final MultiRule rule) {
    EList<RuleElement> _multiruleElements = rule.getMultiruleElements();
    Iterable<CheckDanglingImpl> iterableOfCheckDanglingImpl = Iterables.<CheckDanglingImpl>filter(_multiruleElements, CheckDanglingImpl.class);
    int _size = IterableExtensions.size(iterableOfCheckDanglingImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final CheckDanglingImpl checkDangling : iterableOfCheckDanglingImpl) {
        this.error("CheckDangling can only be used once.\'", checkDangling, Henshin_textPackage.Literals.CHECK_DANGLING__CHECK_DANGLING);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Graph in einer MultiRegel definiert wurde
   * 
   * @param rule Zu überprüfende MultiRegel
   */
  @Check
  public void checkCountGraph(final MultiRule rule) {
    EList<RuleElement> _multiruleElements = rule.getMultiruleElements();
    Iterable<GraphImpl> iterableOfGraphImpl = Iterables.<GraphImpl>filter(_multiruleElements, GraphImpl.class);
    int _size = IterableExtensions.size(iterableOfGraphImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final GraphImpl graph : iterableOfGraphImpl) {
        String _name = rule.getName();
        String _plus = ("Multiple graphs in rule " + _name);
        String _plus_1 = (_plus + ".\'");
        this.error(_plus_1, graph, Henshin_textPackage.Literals.GRAPH__GRAPH_ELEMENTS);
      }
    }
  }
  
  /**
   * Fehler wenn ein Attribut in einem reuse-Knoten definiert wurde das so nicht im ecore-Modell existiert
   * 
   * @param node Zu überprüfender reuse-Knoten
   */
  @Check
  public void checkNodeAttribute(final MultiRuleReuseNode node) {
    EList<Attribute> _attribute = node.getAttribute();
    for (final Attribute attribute : _attribute) {
      {
        boolean superTypeAttribute = false;
        Node _name = node.getName();
        EClass _nodetype = _name.getNodetype();
        EList<EAttribute> _eAttributes = _nodetype.getEAttributes();
        EAttribute _name_1 = attribute.getName();
        boolean _contains = _eAttributes.contains(_name_1);
        boolean _not = (!_contains);
        if (_not) {
          Node _name_2 = node.getName();
          EClass _nodetype_1 = _name_2.getNodetype();
          EList<EClass> _eAllSuperTypes = _nodetype_1.getEAllSuperTypes();
          for (final EClass supertype : _eAllSuperTypes) {
            EList<EAttribute> _eAttributes_1 = supertype.getEAttributes();
            EAttribute _name_3 = attribute.getName();
            boolean _contains_1 = _eAttributes_1.contains(_name_3);
            if (_contains_1) {
              superTypeAttribute = true;
            }
          }
          if ((!superTypeAttribute)) {
            Node _name_4 = node.getName();
            EClass _nodetype_2 = _name_4.getNodetype();
            String _name_5 = _nodetype_2.getName();
            String _plus = (_name_5 + " has no attribute \'");
            EAttribute _name_6 = attribute.getName();
            String _name_7 = _name_6.getName();
            String _plus_1 = (_plus + _name_7);
            String _plus_2 = (_plus_1 + "\'.\'");
            EReference _attribute_Name = Henshin_textPackage.eINSTANCE.getAttribute_Name();
            this.error(_plus_2, attribute, _attribute_Name);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn in einem reuse-Knoten das selbe Attribut mehrfach definiert wird
   * 
   * @param node Zu überprüfender reuse-Knoten
   */
  @Check
  public void checkattributeOnlyOnce(final MultiRuleReuseNode node) {
    for (int i = 0; (i < node.getAttribute().size()); i++) {
      {
        EList<Attribute> _attribute = node.getAttribute();
        Attribute attribute = _attribute.get(i);
        for (int j = (i + 1); (j < node.getAttribute().size()); j++) {
          if ((Objects.equal(attribute.getName(), node.getAttribute().get(j).getName()) && Objects.equal(attribute.getUpdate(), node.getAttribute().get(j).getUpdate()))) {
            EAttribute _name = attribute.getName();
            String _name_1 = _name.getName();
            String _plus = ("\'" + _name_1);
            String _plus_1 = (_plus + "\' can only be used once.\'");
            EList<Attribute> _attribute_1 = node.getAttribute();
            Attribute _get = _attribute_1.get(j);
            EReference _attribute_Name = Henshin_textPackage.eINSTANCE.getAttribute_Name();
            this.error(_plus_1, _get, _attribute_Name);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn ein forbid- oder require-Knoten in einer Kanten einer MultiRegel wiederverwendet werden soll
   * 
   * @param conNodes Liste von forbid- und require-Knoten von darüberliegenden Graphen
   * @param graph Zu überprüfender Graph
   */
  private void checkEdgesInMultiRuleRekursive(final List<Node> conNodes, final Graph graph) {
    EList<GraphElements> _graphElements = graph.getGraphElements();
    Iterable<Edges> _filter = Iterables.<Edges>filter(_graphElements, Edges.class);
    for (final Edges edges : _filter) {
      EList<Edge> _edges = edges.getEdges();
      for (final Edge edge : _edges) {
        {
          Node testNode = null;
          RuleNodeTypes _source = edge.getSource();
          boolean _notEquals = (!Objects.equal(_source, null));
          if (_notEquals) {
            RuleNodeTypes _source_1 = edge.getSource();
            if ((_source_1 instanceof Node)) {
              RuleNodeTypes _source_2 = edge.getSource();
              testNode = ((Node) _source_2);
            } else {
              try {
                RuleNodeTypes _source_3 = edge.getSource();
                Node _name = ((MultiRuleReuseNode) _source_3).getName();
                testNode = _name;
              } catch (final Throwable _t) {
                if (_t instanceof ClassCastException) {
                  final ClassCastException e = (ClassCastException)_t;
                  testNode = null;
                } else {
                  throw Exceptions.sneakyThrow(_t);
                }
              }
            }
          }
          for (final Node conNode : conNodes) {
            String _name_1 = conNode.getName();
            String _name_2 = testNode.getName();
            boolean _equals = Objects.equal(_name_1, _name_2);
            if (_equals) {
              String _actiontype = testNode.getActiontype();
              String _plus = (_actiontype + "-nodes are not allowed to be reused in edges in MultiRuleReuseNodes.\'");
              EReference _edge_Source = Henshin_textPackage.eINSTANCE.getEdge_Source();
              this.error(_plus, edge, _edge_Source);
            }
          }
          RuleNodeTypes _target = edge.getTarget();
          boolean _notEquals_1 = (!Objects.equal(_target, null));
          if (_notEquals_1) {
            RuleNodeTypes _target_1 = edge.getTarget();
            if ((_target_1 instanceof Node)) {
              RuleNodeTypes _target_2 = edge.getTarget();
              testNode = ((Node) _target_2);
            } else {
              RuleNodeTypes _target_3 = edge.getTarget();
              Node _name_3 = ((MultiRuleReuseNode) _target_3).getName();
              testNode = _name_3;
            }
          }
          for (final Node conNode_1 : conNodes) {
            String _name_4 = conNode_1.getName();
            String _name_5 = testNode.getName();
            boolean _equals_1 = Objects.equal(_name_4, _name_5);
            if (_equals_1) {
              String _actiontype_1 = testNode.getActiontype();
              String _plus_1 = (_actiontype_1 + "-nodes are not allowed to be reused in edges in MultiRuleReuseNodes.\'");
              EReference _edge_Target = Henshin_textPackage.eINSTANCE.getEdge_Target();
              this.error(_plus_1, edge, _edge_Target);
            }
          }
        }
      }
    }
    EList<GraphElements> _graphElements_1 = graph.getGraphElements();
    Iterable<MultiRule> multiRules = Iterables.<MultiRule>filter(_graphElements_1, MultiRule.class);
    int _size = IterableExtensions.size(multiRules);
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      EList<GraphElements> _graphElements_2 = graph.getGraphElements();
      Iterable<Node> _filter_1 = Iterables.<Node>filter(_graphElements_2, Node.class);
      for (final Node node : _filter_1) {
        if ((Objects.equal(node.getActiontype(), "forbid") || Objects.equal(node.getActiontype(), "require"))) {
          conNodes.add(node);
        }
      }
      for (final MultiRule multiRule : multiRules) {
        EList<RuleElement> _multiruleElements = multiRule.getMultiruleElements();
        Iterable<Graph> _filter_2 = Iterables.<Graph>filter(_multiruleElements, Graph.class);
        Graph _get = ((Graph[])Conversions.unwrapArray(_filter_2, Graph.class))[0];
        this.checkEdgesInMultiRuleRekursive(conNodes, _get);
      }
    }
  }
  
  /**
   * Fehler wenn ein forbid- oder require-Knoten in einer Kanten einer MultiRegel wiederverwendet werden soll
   * 
   * @paran rule Zu überprüfende Regel
   */
  @Check
  public void checkEdgesInMultiRule(final Rule rule) {
    EList<RuleElement> _ruleElements = rule.getRuleElements();
    Iterable<Graph> graph = Iterables.<Graph>filter(_ruleElements, Graph.class);
    int _size = IterableExtensions.size(graph);
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      List<Node> conNodes = new ArrayList<Node>();
      final Iterable<Graph> _converted_graph = (Iterable<Graph>)graph;
      Graph _get = ((Graph[])Conversions.unwrapArray(_converted_graph, Graph.class))[0];
      EList<GraphElements> _graphElements = _get.getGraphElements();
      Iterable<Node> _filter = Iterables.<Node>filter(_graphElements, Node.class);
      for (final Node node : _filter) {
        if ((Objects.equal(node.getActiontype(), "forbid") || Objects.equal(node.getActiontype(), "require"))) {
          conNodes.add(node);
        }
      }
      final Iterable<Graph> _converted_graph_1 = (Iterable<Graph>)graph;
      Graph _get_1 = ((Graph[])Conversions.unwrapArray(_converted_graph_1, Graph.class))[0];
      EList<GraphElements> _graphElements_1 = _get_1.getGraphElements();
      Iterable<MultiRule> _filter_1 = Iterables.<MultiRule>filter(_graphElements_1, MultiRule.class);
      for (final MultiRule multiRule : _filter_1) {
        EList<RuleElement> _multiruleElements = multiRule.getMultiruleElements();
        Iterable<Graph> _filter_2 = Iterables.<Graph>filter(_multiruleElements, Graph.class);
        int _size_1 = IterableExtensions.size(_filter_2);
        boolean _greaterThan_1 = (_size_1 > 0);
        if (_greaterThan_1) {
          EList<RuleElement> _multiruleElements_1 = multiRule.getMultiruleElements();
          Iterable<Graph> _filter_3 = Iterables.<Graph>filter(_multiruleElements_1, Graph.class);
          Graph _get_2 = ((Graph[])Conversions.unwrapArray(_filter_3, Graph.class))[0];
          this.checkEdgesInMultiRuleRekursive(conNodes, _get_2);
        }
      }
    }
  }
  
  /**
   * Fehler wenn ein Knoten mit ActionType require oder forbid reused wird
   * 
   * @parameter multiReuseNode Zu überprüfender reuse-Node
   */
  @Check
  public void checkMultiRuleReuseNodeActionType(final MultiRuleReuseNode multiReuseNode) {
    if ((Objects.equal(multiReuseNode.getName().getActiontype(), "require") || Objects.equal(multiReuseNode.getName().getActiontype(), "forbid"))) {
      Node _name = multiReuseNode.getName();
      String _actiontype = _name.getActiontype();
      String _plus = (_actiontype + "-Node \'");
      Node _name_1 = multiReuseNode.getName();
      String _name_2 = _name_1.getName();
      String _plus_1 = (_plus + _name_2);
      String _plus_2 = (_plus_1 + "\' is not allowed in MultiRules.\'");
      EReference _multiRuleReuseNode_Name = Henshin_textPackage.eINSTANCE.getMultiRuleReuseNode_Name();
      this.error(_plus_2, multiReuseNode, _multiRuleReuseNode_Name);
    }
  }
  
  /**
   * Fehler wenn in einem reuse-Node ein set-Attribut definiert wurde
   * 
   * @param reuseNode Zu überprüfender reuse-Node
   */
  @Check
  public void checkMultiRuleReuseNodAttributeSet(final MultiRuleReuseNode reuseNode) {
    EList<Attribute> _attribute = reuseNode.getAttribute();
    for (final Attribute attribute : _attribute) {
      String _update = attribute.getUpdate();
      boolean _notEquals = (!Objects.equal(_update, null));
      if (_notEquals) {
        EAttribute _attribute_Actiontype = Henshin_textPackage.eINSTANCE.getAttribute_Actiontype();
        this.error("Set-attributes are not allowed in MultiRuleReuseNodes.\'", attribute, _attribute_Actiontype);
      }
    }
  }
  
  /**
   * Fehler wenn der ActionType der Attribute eines reuse-Nodes nicht zum ActionType des orginal Knoten passen
   * 
   * @param reuseNode Zu überprüfender reuse-Node
   */
  @Check
  public void checkMultiRuleReuseNodAttributeAction(final MultiRuleReuseNode reuseNode) {
    Node _name = reuseNode.getName();
    String reuseNodeType = _name.getActiontype();
    boolean _equals = Objects.equal(reuseNodeType, null);
    if (_equals) {
      reuseNodeType = "preserve";
    }
    Node _name_1 = reuseNode.getName();
    String _actiontype = _name_1.getActiontype();
    boolean _equals_1 = Objects.equal(_actiontype, "create");
    if (_equals_1) {
      EList<Attribute> _attribute = reuseNode.getAttribute();
      for (final Attribute attribute : _attribute) {
        if (((!Objects.equal(attribute.getActiontype(), "create")) && (!Objects.equal(attribute.getActiontype(), null)))) {
          String _actiontype_1 = attribute.getActiontype();
          String _plus = (_actiontype_1 + "-attributes are not allowed in ");
          String _plus_1 = (_plus + reuseNodeType);
          String _plus_2 = (_plus_1 + "-reuseNodes. \'");
          EAttribute _attribute_Actiontype = Henshin_textPackage.eINSTANCE.getAttribute_Actiontype();
          this.error(_plus_2, attribute, _attribute_Actiontype);
        }
      }
    } else {
      Node _name_2 = reuseNode.getName();
      String _actiontype_2 = _name_2.getActiontype();
      boolean _equals_2 = Objects.equal(_actiontype_2, "delete");
      if (_equals_2) {
        EList<Attribute> _attribute_1 = reuseNode.getAttribute();
        for (final Attribute attribute_1 : _attribute_1) {
          if (((!Objects.equal(attribute_1.getActiontype(), "delete")) && (!Objects.equal(attribute_1.getActiontype(), null)))) {
            String _actiontype_3 = attribute_1.getActiontype();
            String _plus_3 = (_actiontype_3 + "-attributes are not allowed in ");
            String _plus_4 = (_plus_3 + reuseNodeType);
            String _plus_5 = (_plus_4 + "-reuseNodes. \'");
            EAttribute _attribute_Actiontype_1 = Henshin_textPackage.eINSTANCE.getAttribute_Actiontype();
            this.error(_plus_5, attribute_1, _attribute_Actiontype_1);
          }
        }
      } else {
        if ((Objects.equal(reuseNode.getName().getActiontype(), "preserve") || Objects.equal(reuseNode.getName().getActiontype(), null))) {
          EList<Attribute> _attribute_2 = reuseNode.getAttribute();
          for (final Attribute attribute_2 : _attribute_2) {
            if ((Objects.equal(attribute_2.getActiontype(), "forbid") || Objects.equal(attribute_2.getActiontype(), "require"))) {
              String _actiontype_4 = attribute_2.getActiontype();
              String _plus_6 = (_actiontype_4 + "-attributes are not allowed in ");
              String _plus_7 = (_plus_6 + reuseNodeType);
              String _plus_8 = (_plus_7 + "-reuseNodes. \'");
              EAttribute _attribute_Actiontype_2 = Henshin_textPackage.eINSTANCE.getAttribute_Actiontype();
              this.error(_plus_8, attribute_2, _attribute_Actiontype_2);
            }
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn ein Graph der nicht zu einer MultiRegel gehört einen Knoten reused
   * 
   * @param rule Zu überprüfende Regel
   */
  @Check
  public void checkRuleReuseNodes(final Rule rule) {
    EList<RuleElement> _ruleElements = rule.getRuleElements();
    Iterable<Graph> graph = Iterables.<Graph>filter(_ruleElements, Graph.class);
    int _size = IterableExtensions.size(graph);
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      final Iterable<Graph> _converted_graph = (Iterable<Graph>)graph;
      Graph _get = ((Graph[])Conversions.unwrapArray(_converted_graph, Graph.class))[0];
      EList<GraphElements> _graphElements = _get.getGraphElements();
      Iterable<MultiRuleReuseNode> reuseNodes = Iterables.<MultiRuleReuseNode>filter(_graphElements, MultiRuleReuseNode.class);
      for (final MultiRuleReuseNode node : reuseNodes) {
        EReference _multiRuleReuseNode_Name = Henshin_textPackage.eINSTANCE.getMultiRuleReuseNode_Name();
        this.error("Reuse-Nodes are only allowed in multiRules.\'\'", node, _multiRuleReuseNode_Name);
      }
    }
  }
  
  /**
   * Fehler wenn ein Knoten wie ein MultiRuleReuseNode benannt wurde
   * 
   * @param graph Zu überprüfender Graph
   */
  @Check
  public void checkMultiRuleGraphNodes(final Graph graph) {
    EList<GraphElements> _graphElements = graph.getGraphElements();
    Iterable<MultiRuleReuseNode> _filter = Iterables.<MultiRuleReuseNode>filter(_graphElements, MultiRuleReuseNode.class);
    for (final MultiRuleReuseNode reuse : _filter) {
      EList<GraphElements> _graphElements_1 = graph.getGraphElements();
      Iterable<Node> _filter_1 = Iterables.<Node>filter(_graphElements_1, Node.class);
      for (final Node node : _filter_1) {
        Node _name = reuse.getName();
        String _name_1 = _name.getName();
        String _name_2 = node.getName();
        boolean _equals = Objects.equal(_name_1, _name_2);
        if (_equals) {
          EReference _multiRuleReuseNode_Name = Henshin_textPackage.eINSTANCE.getMultiRuleReuseNode_Name();
          this.error("Graph cannot reuse its own nodes.\'", reuse, _multiRuleReuseNode_Name);
        }
      }
    }
  }
  
  /**
   * Fehler wenn ein Knoten mehrfach reused wird in einem Graphen
   * 
   * @param graph Zu überprüfender Graph
   */
  @Check
  public void checkGraphMultiReuse(final Graph graph) {
    EList<GraphElements> _graphElements = graph.getGraphElements();
    Iterable<MultiRuleReuseNode> reuseNodes = Iterables.<MultiRuleReuseNode>filter(_graphElements, MultiRuleReuseNode.class);
    for (int i = 0; (i < IterableExtensions.size(reuseNodes)); i++) {
      for (int j = (i + 1); (j < IterableExtensions.size(reuseNodes)); j++) {
        final Iterable<MultiRuleReuseNode> _converted_reuseNodes = (Iterable<MultiRuleReuseNode>)reuseNodes;
        MultiRuleReuseNode _get = ((MultiRuleReuseNode[])Conversions.unwrapArray(_converted_reuseNodes, MultiRuleReuseNode.class))[i];
        Node _name = _get.getName();
        String _name_1 = _name.getName();
        final Iterable<MultiRuleReuseNode> _converted_reuseNodes_1 = (Iterable<MultiRuleReuseNode>)reuseNodes;
        MultiRuleReuseNode _get_1 = ((MultiRuleReuseNode[])Conversions.unwrapArray(_converted_reuseNodes_1, MultiRuleReuseNode.class))[j];
        Node _name_2 = _get_1.getName();
        String _name_3 = _name_2.getName();
        boolean _equals = Objects.equal(_name_1, _name_3);
        if (_equals) {
          final Iterable<MultiRuleReuseNode> _converted_reuseNodes_2 = (Iterable<MultiRuleReuseNode>)reuseNodes;
          MultiRuleReuseNode _get_2 = ((MultiRuleReuseNode[])Conversions.unwrapArray(_converted_reuseNodes_2, MultiRuleReuseNode.class))[j];
          Node _name_4 = _get_2.getName();
          String _name_5 = _name_4.getName();
          String _plus = (_name_5 + " is already reused.\'");
          final Iterable<MultiRuleReuseNode> _converted_reuseNodes_3 = (Iterable<MultiRuleReuseNode>)reuseNodes;
          EObject _get_3 = ((EObject[])Conversions.unwrapArray(_converted_reuseNodes_3, EObject.class))[j];
          EReference _multiRuleReuseNode_Name = Henshin_textPackage.eINSTANCE.getMultiRuleReuseNode_Name();
          this.error(_plus, _get_3, _multiRuleReuseNode_Name);
        }
      }
    }
  }
  
  /**
   * Fehler wenn ein Graph einer MultiRegel einen Knoten eines darüberliegenden Graphen überschreibt
   * 
   * @param graph Graph der rekursiv durchsucht wird
   */
  @Check
  public void checkOverrideNodeNamesinMultiRuleGraph(final Graph graph) {
    EList<GraphElements> _graphElements = graph.getGraphElements();
    Iterable<MultiRule> multiRules = Iterables.<MultiRule>filter(_graphElements, MultiRule.class);
    List<Node> topNodes = new ArrayList<Node>();
    for (final MultiRule rule : multiRules) {
      EList<RuleElement> _multiruleElements = rule.getMultiruleElements();
      Iterable<Graph> _filter = Iterables.<Graph>filter(_multiruleElements, Graph.class);
      for (final Graph multiGraph : _filter) {
        {
          EList<GraphElements> _graphElements_1 = multiGraph.getGraphElements();
          Iterable<Node> _filter_1 = Iterables.<Node>filter(_graphElements_1, Node.class);
          for (final Node multiNode : _filter_1) {
            EList<GraphElements> _graphElements_2 = graph.getGraphElements();
            Iterable<Node> _filter_2 = Iterables.<Node>filter(_graphElements_2, Node.class);
            for (final Node node : _filter_2) {
              {
                topNodes.add(node);
                String _name = multiNode.getName();
                String _name_1 = node.getName();
                boolean _equals = Objects.equal(_name, _name_1);
                if (_equals) {
                  String _name_2 = multiNode.getName();
                  String _plus = ("Duplicate Node \'" + _name_2);
                  String _plus_1 = (_plus + "\'.\'");
                  EReference _node_Nodetype = Henshin_textPackage.eINSTANCE.getNode_Nodetype();
                  this.error(_plus_1, multiNode, _node_Nodetype);
                }
              }
            }
          }
          EList<GraphElements> _graphElements_3 = multiGraph.getGraphElements();
          Iterable<MultiRule> _filter_3 = Iterables.<MultiRule>filter(_graphElements_3, MultiRule.class);
          int _size = IterableExtensions.size(_filter_3);
          boolean _greaterThan = (_size > 0);
          if (_greaterThan) {
            this.checkRekursiveOverrideNodeNamesinMultiRuleGraph(topNodes, multiGraph);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn ein Graph einer MultiRegel einen Knoten eines darüberliegenden Graphen überschreibt
   * 
   * @param topNodes Liste der darüberliegenden Graphknoten
   * @param graph Zu überprüfender Graph
   */
  private void checkRekursiveOverrideNodeNamesinMultiRuleGraph(final List<Node> topNodes, final Graph graph) {
    EList<GraphElements> _graphElements = graph.getGraphElements();
    Iterable<MultiRule> multiRules = Iterables.<MultiRule>filter(_graphElements, MultiRule.class);
    for (final MultiRule rule : multiRules) {
      EList<RuleElement> _multiruleElements = rule.getMultiruleElements();
      Iterable<Graph> _filter = Iterables.<Graph>filter(_multiruleElements, Graph.class);
      for (final Graph multiGraph : _filter) {
        {
          EList<GraphElements> _graphElements_1 = multiGraph.getGraphElements();
          Iterable<Node> _filter_1 = Iterables.<Node>filter(_graphElements_1, Node.class);
          for (final Node multiNode : _filter_1) {
            {
              for (final Node node : topNodes) {
                String _name = multiNode.getName();
                String _name_1 = node.getName();
                boolean _equals = Objects.equal(_name, _name_1);
                if (_equals) {
                  String _name_2 = multiNode.getName();
                  String _plus = ("Duplicate Node \'" + _name_2);
                  String _plus_1 = (_plus + "\'.\'");
                  EReference _node_Nodetype = Henshin_textPackage.eINSTANCE.getNode_Nodetype();
                  this.error(_plus_1, multiNode, _node_Nodetype);
                }
              }
              EList<GraphElements> _graphElements_2 = graph.getGraphElements();
              Iterable<Node> _filter_2 = Iterables.<Node>filter(_graphElements_2, Node.class);
              for (final Node node_1 : _filter_2) {
                {
                  topNodes.add(node_1);
                  String _name_3 = multiNode.getName();
                  String _name_4 = node_1.getName();
                  boolean _equals_1 = Objects.equal(_name_3, _name_4);
                  if (_equals_1) {
                    String _name_5 = multiNode.getName();
                    String _plus_2 = ("Duplicate Node \'" + _name_5);
                    String _plus_3 = (_plus_2 + "\'.\'");
                    EReference _node_Nodetype_1 = Henshin_textPackage.eINSTANCE.getNode_Nodetype();
                    this.error(_plus_3, multiNode, _node_Nodetype_1);
                  }
                }
              }
            }
          }
          EList<GraphElements> _graphElements_2 = multiGraph.getGraphElements();
          Iterable<MultiRule> _filter_2 = Iterables.<MultiRule>filter(_graphElements_2, MultiRule.class);
          int _size = IterableExtensions.size(_filter_2);
          boolean _greaterThan = (_size > 0);
          if (_greaterThan) {
            this.checkRekursiveOverrideNodeNamesinMultiRuleGraph(topNodes, multiGraph);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn eine Kante in einem ConditionGraph definiert wurde, die nicht im ecore-Modell existiert
   * 
   * @param edge Zu überprüfende Kante
   */
  @Check
  public void ckeckExistingEdge(final ConditionEdge edge) {
    EClass sourceType = null;
    EClass targetType = null;
    ConditionNodeTypes _source = edge.getSource();
    if ((_source instanceof Node)) {
      ConditionNodeTypes _source_1 = edge.getSource();
      EClass _nodetype = ((Node) _source_1).getNodetype();
      sourceType = _nodetype;
    } else {
      try {
        ConditionNodeTypes _source_2 = edge.getSource();
        EClass _type = ((ConditionNode) _source_2).getType();
        sourceType = _type;
      } catch (final Throwable _t) {
        if (_t instanceof ClassCastException) {
          final ClassCastException e = (ClassCastException)_t;
          sourceType = null;
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
    }
    ConditionNodeTypes _target = edge.getTarget();
    if ((_target instanceof Node)) {
      ConditionNodeTypes _target_1 = edge.getTarget();
      EClass _nodetype_1 = ((Node) _target_1).getNodetype();
      targetType = _nodetype_1;
    } else {
      try {
        ConditionNodeTypes _target_2 = edge.getTarget();
        EClass _type_1 = ((ConditionNode) _target_2).getType();
        targetType = _type_1;
      } catch (final Throwable _t_1) {
        if (_t_1 instanceof ClassCastException) {
          final ClassCastException e_1 = (ClassCastException)_t_1;
          targetType = null;
        } else {
          throw Exceptions.sneakyThrow(_t_1);
        }
      }
    }
    if (((!Objects.equal(sourceType, null)) && (!Objects.equal(targetType, null)))) {
      boolean wrongType = true;
      EClass referenceType = null;
      EList<EReference> _eAllReferences = sourceType.getEAllReferences();
      for (final EReference reference : _eAllReferences) {
        EReference _type_2 = edge.getType();
        String _name = _type_2.getName();
        String _name_1 = reference.getName();
        boolean _equals = Objects.equal(_name, _name_1);
        if (_equals) {
          wrongType = false;
          EClass _eReferenceType = reference.getEReferenceType();
          referenceType = _eReferenceType;
        }
      }
      if (wrongType) {
        EReference _type_3 = edge.getType();
        String _name_2 = _type_3.getName();
        String _plus = ("Edgetype " + _name_2);
        String _plus_1 = (_plus + " does not exist.\'");
        EReference _conditionEdge_Type = Henshin_textPackage.eINSTANCE.getConditionEdge_Type();
        this.error(_plus_1, edge, _conditionEdge_Type);
      }
      boolean _notEquals = (!Objects.equal(referenceType, targetType));
      if (_notEquals) {
        String _name_3 = sourceType.getName();
        String _plus_2 = ("Edge " + _name_3);
        String _plus_3 = (_plus_2 + "->");
        String _name_4 = targetType.getName();
        String _plus_4 = (_plus_3 + _name_4);
        String _plus_5 = (_plus_4 + ":");
        EReference _type_4 = edge.getType();
        String _name_5 = _type_4.getName();
        String _plus_6 = (_plus_5 + _name_5);
        String _plus_7 = (_plus_6 + " does not exist.\'");
        EReference _conditionEdge_Type_1 = Henshin_textPackage.eINSTANCE.getConditionEdge_Type();
        this.error(_plus_7, edge, _conditionEdge_Type_1);
      }
    }
  }
  
  /**
   * Fehler wenn ein Attribut in einem Knoten eines ConditionGraphen definiert wurde das so nicht im ecore-Modell existiert
   * 
   * @param node Zu überprüfender Knoten eines ConditionGraphen
   */
  @Check
  public void checkNodeAttribute(final ConditionNode node) {
    EList<Match> _attribute = node.getAttribute();
    for (final Match attribute : _attribute) {
      {
        boolean superTypeAttribute = false;
        EClass _type = node.getType();
        EList<EAttribute> _eAttributes = _type.getEAttributes();
        EAttribute _name = attribute.getName();
        boolean _contains = _eAttributes.contains(_name);
        boolean _not = (!_contains);
        if (_not) {
          EClass _type_1 = node.getType();
          EList<EClass> _eAllSuperTypes = _type_1.getEAllSuperTypes();
          for (final EClass supertype : _eAllSuperTypes) {
            EList<EAttribute> _eAttributes_1 = supertype.getEAttributes();
            EAttribute _name_1 = attribute.getName();
            boolean _contains_1 = _eAttributes_1.contains(_name_1);
            if (_contains_1) {
              superTypeAttribute = true;
            }
          }
          if ((!superTypeAttribute)) {
            EClass _type_2 = node.getType();
            String _name_2 = _type_2.getName();
            String _plus = (_name_2 + " has no attribute \'");
            EAttribute _name_3 = attribute.getName();
            String _name_4 = _name_3.getName();
            String _plus_1 = (_plus + _name_4);
            String _plus_2 = (_plus_1 + "\'.\'");
            EReference _match_Name = Henshin_textPackage.eINSTANCE.getMatch_Name();
            this.error(_plus_2, attribute, _match_Name);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn ein Knotentyp verwendet wurde, der nicht importiert wurde
   * 
   * @param node Zu überprüfender Knoten
   */
  @Check
  public void checkConditionNodeType(final ConditionNode node) {
    boolean isImported = false;
    List<EPackageImport> _ePackageImports = this.getEPackageImports(node);
    for (final EPackageImport ePackage : _ePackageImports) {
      EPackage _ref = ePackage.getRef();
      EList<EClassifier> _eClassifiers = _ref.getEClassifiers();
      EClass _type = node.getType();
      boolean _contains = _eClassifiers.contains(_type);
      if (_contains) {
        isImported = true;
      }
    }
    if ((!isImported)) {
      EClass _type_1 = node.getType();
      String _name = _type_1.getName();
      String _plus = ("Nodetype " + _name);
      String _plus_1 = (_plus + " is not imported.\'");
      EReference _conditionNode_Type = Henshin_textPackage.eINSTANCE.getConditionNode_Type();
      this.error(_plus_1, node, _conditionNode_Type);
    }
  }
  
  /**
   * Fehler wenn ein Attribut in einem reuse-Knoten eines ConditionGraphen definiert wurde das so nicht im ecore-Modell existiert
   * 
   * @param node Zu überprüfender reuse-Knoten eines ConditionGraphen
   */
  @Check
  public void checkNodeAttribute(final ConditionReuseNode node) {
    EClass nodeType = null;
    ConditionNodeTypes _name = node.getName();
    if ((_name instanceof Node)) {
      ConditionNodeTypes _name_1 = node.getName();
      EClass _nodetype = ((Node) _name_1).getNodetype();
      nodeType = _nodetype;
    } else {
      try {
        ConditionNodeTypes _name_2 = node.getName();
        EClass _type = ((ConditionNode) _name_2).getType();
        nodeType = _type;
      } catch (final Throwable _t) {
        if (_t instanceof ClassCastException) {
          final ClassCastException e = (ClassCastException)_t;
          nodeType = null;
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
    }
    boolean _notEquals = (!Objects.equal(nodeType, null));
    if (_notEquals) {
      EList<Match> _attribute = node.getAttribute();
      for (final Match attribute : _attribute) {
        {
          boolean superTypeAttribute = false;
          EList<EAttribute> _eAttributes = nodeType.getEAttributes();
          EAttribute _name_3 = attribute.getName();
          boolean _contains = _eAttributes.contains(_name_3);
          boolean _not = (!_contains);
          if (_not) {
            EList<EClass> _eAllSuperTypes = nodeType.getEAllSuperTypes();
            for (final EClass supertype : _eAllSuperTypes) {
              EList<EAttribute> _eAttributes_1 = supertype.getEAttributes();
              EAttribute _name_4 = attribute.getName();
              boolean _contains_1 = _eAttributes_1.contains(_name_4);
              if (_contains_1) {
                superTypeAttribute = true;
              }
            }
            if ((!superTypeAttribute)) {
              String _name_5 = nodeType.getName();
              String _plus = (_name_5 + " has no attribute \'");
              EAttribute _name_6 = attribute.getName();
              String _name_7 = _name_6.getName();
              String _plus_1 = (_plus + _name_7);
              String _plus_2 = (_plus_1 + "\'.\'");
              EReference _match_Name = Henshin_textPackage.eINSTANCE.getMatch_Name();
              this.error(_plus_2, attribute, _match_Name);
            }
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn in einem Knoten eines ConditionGraphen das selbe Attribut mehrfach definiert wird
   * 
   * @param node Zu überprüfender Knoten
   */
  @Check
  public void checkattributeOnlyOnce(final ConditionNode node) {
    for (int i = 0; (i < node.getAttribute().size()); i++) {
      {
        EList<Match> _attribute = node.getAttribute();
        Match match = _attribute.get(i);
        for (int j = (i + 1); (j < node.getAttribute().size()); j++) {
          EAttribute _name = match.getName();
          EList<Match> _attribute_1 = node.getAttribute();
          Match _get = _attribute_1.get(j);
          EAttribute _name_1 = _get.getName();
          boolean _equals = Objects.equal(_name, _name_1);
          if (_equals) {
            EAttribute _name_2 = match.getName();
            String _name_3 = _name_2.getName();
            String _plus = ("\'" + _name_3);
            String _plus_1 = (_plus + "\' can only be used once.\'");
            EList<Match> _attribute_2 = node.getAttribute();
            Match _get_1 = _attribute_2.get(j);
            EReference _match_Name = Henshin_textPackage.eINSTANCE.getMatch_Name();
            this.error(_plus_1, _get_1, _match_Name);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn in einem reuse-Knoten eines ConditionGraphen das selbe Attribut mehrfach definiert wird
   * 
   * @param node Zu überprüfender Knoten
   */
  @Check
  public void checkattributeOnlyOnce(final ConditionReuseNode node) {
    for (int i = 0; (i < node.getAttribute().size()); i++) {
      {
        EList<Match> _attribute = node.getAttribute();
        Match match = _attribute.get(i);
        for (int j = (i + 1); (j < node.getAttribute().size()); j++) {
          EAttribute _name = match.getName();
          EList<Match> _attribute_1 = node.getAttribute();
          Match _get = _attribute_1.get(j);
          EAttribute _name_1 = _get.getName();
          boolean _equals = Objects.equal(_name, _name_1);
          if (_equals) {
            EAttribute _name_2 = match.getName();
            String _name_3 = _name_2.getName();
            String _plus = ("\'" + _name_3);
            String _plus_1 = (_plus + "\' can only be used once.\'");
            EList<Match> _attribute_2 = node.getAttribute();
            Match _get_1 = _attribute_2.get(j);
            EReference _match_Name = Henshin_textPackage.eINSTANCE.getMatch_Name();
            this.error(_plus_1, _get_1, _match_Name);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn ein Knoten in einem ConditionGraphen reused wird der nicht zur LHS gehört
   * 
   * @param conReuseNode Zu überprüfender reuse-Node
   */
  @Check
  public void checkConditionReuseNodeInLHS(final ConditionReuseNode conReuseNode) {
    ConditionNodeTypes _name = conReuseNode.getName();
    if ((_name instanceof Node)) {
      if ((((!Objects.equal(((Node) conReuseNode.getName()).getActiontype(), null)) && (!Objects.equal(((Node) conReuseNode.getName()).getActiontype(), "preserve"))) && (!Objects.equal(((Node) conReuseNode.getName()).getActiontype(), "delete")))) {
        ConditionNodeTypes _name_1 = conReuseNode.getName();
        String _name_2 = ((Node) _name_1).getName();
        String _plus = ("Node \'" + _name_2);
        String _plus_1 = (_plus + "\' is not in LHS.\'");
        EReference _conditionReuseNode_Name = Henshin_textPackage.eINSTANCE.getConditionReuseNode_Name();
        this.error(_plus_1, conReuseNode, _conditionReuseNode_Name);
      }
    }
  }
  
  /**
   * Fehler wenn ein Knoten in einer Kante im ConditionGraph wiederverwendet wird der nicht zur LHS gehört
   * 
   * @param conEdge zu überprüfende Kante
   */
  @Check
  public void checkConditionEdgeInLHS(final ConditionEdge conEdge) {
    ConditionNodeTypes _source = conEdge.getSource();
    if ((_source instanceof Node)) {
      if ((((!Objects.equal(((Node) conEdge.getSource()).getActiontype(), null)) && (!Objects.equal(((Node) conEdge.getSource()).getActiontype(), "preserve"))) && (!Objects.equal(((Node) conEdge.getSource()).getActiontype(), "delete")))) {
        ConditionNodeTypes _source_1 = conEdge.getSource();
        String _name = ((Node) _source_1).getName();
        String _plus = ("Node \'" + _name);
        String _plus_1 = (_plus + "\' is not in LHS.\'");
        EReference _conditionEdge_Source = Henshin_textPackage.eINSTANCE.getConditionEdge_Source();
        this.error(_plus_1, conEdge, _conditionEdge_Source);
      }
    }
    ConditionNodeTypes _target = conEdge.getTarget();
    if ((_target instanceof Node)) {
      if ((((!Objects.equal(((Node) conEdge.getTarget()).getActiontype(), null)) && (!Objects.equal(((Node) conEdge.getTarget()).getActiontype(), "preserve"))) && (!Objects.equal(((Node) conEdge.getTarget()).getActiontype(), "delete")))) {
        ConditionNodeTypes _target_1 = conEdge.getTarget();
        String _name_1 = ((Node) _target_1).getName();
        String _plus_2 = ("Node \'" + _name_1);
        String _plus_3 = (_plus_2 + "\' is not in LHS.\'");
        EReference _conditionEdge_Target = Henshin_textPackage.eINSTANCE.getConditionEdge_Target();
        this.error(_plus_3, conEdge, _conditionEdge_Target);
      }
    }
  }
  
  /**
   * Fehler wenn in einem Graph mehrere matchingFormula-Elemente definiert wurden
   * 
   * @param graph Zu überprüfender Graph
   */
  @Check
  public void matchingFormulaOnce(final Graph graph) {
    EList<GraphElements> _graphElements = graph.getGraphElements();
    Iterable<Formula> formulaList = Iterables.<Formula>filter(_graphElements, Formula.class);
    int _size = IterableExtensions.size(formulaList);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final Formula formula : formulaList) {
        this.error("matchingFormula can only use once.\'", formula, Henshin_textPackage.Literals.FORMULA__FORMULA);
      }
    }
  }
  
  /**
   * Fehler wenn in einem ConditionGraph mehrere matchingFormula-Elemente definiert wurden
   * 
   * @param graph Zu überprüfender ConditionGraph
   */
  @Check
  public void matchingFormulaOnce(final ConditionGraph graph) {
    EList<ConditionGraphElements> _conditionGraphElements = graph.getConditionGraphElements();
    Iterable<Formula> formulaList = Iterables.<Formula>filter(_conditionGraphElements, Formula.class);
    int _size = IterableExtensions.size(formulaList);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final Formula formula : formulaList) {
        this.error("matchingFormula can only use once.\'", formula, Henshin_textPackage.Literals.FORMULA__FORMULA);
      }
    }
  }
  
  /**
   * Fehler wenn ein ConditionGraph einen Knoten eines darüberliegenden Graphen überschreibt
   * 
   * @param graph Graph der rekursiv durchsucht wird
   */
  @Check
  public void checkOverrideNodeNamesinConditionGraph(final Graph graph) {
    EList<GraphElements> _graphElements = graph.getGraphElements();
    Iterable<Formula> formula = Iterables.<Formula>filter(_graphElements, Formula.class);
    List<ConditionNode> topConNodes = new ArrayList<ConditionNode>();
    int _size = IterableExtensions.size(formula);
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      final Iterable<Formula> _converted_formula = (Iterable<Formula>)formula;
      Formula _get = ((Formula[])Conversions.unwrapArray(_converted_formula, Formula.class))[0];
      EList<ConditionGraph> _conditionGraphs = _get.getConditionGraphs();
      for (final ConditionGraph conGraph : _conditionGraphs) {
        {
          EList<ConditionGraphElements> _conditionGraphElements = conGraph.getConditionGraphElements();
          Iterable<ConditionNode> _filter = Iterables.<ConditionNode>filter(_conditionGraphElements, ConditionNode.class);
          for (final ConditionNode conNode : _filter) {
            {
              EList<GraphElements> _graphElements_1 = graph.getGraphElements();
              Iterable<Node> _filter_1 = Iterables.<Node>filter(_graphElements_1, Node.class);
              for (final Node node : _filter_1) {
                String _name = conNode.getName();
                String _name_1 = node.getName();
                boolean _equals = Objects.equal(_name, _name_1);
                if (_equals) {
                  String _name_2 = conNode.getName();
                  String _plus = ("Duplicate Node \'" + _name_2);
                  String _plus_1 = (_plus + "\'.\'");
                  EReference _conditionNode_Type = Henshin_textPackage.eINSTANCE.getConditionNode_Type();
                  this.error(_plus_1, conNode, _conditionNode_Type);
                }
              }
              topConNodes.add(conNode);
            }
          }
          EList<ConditionGraphElements> _conditionGraphElements_1 = conGraph.getConditionGraphElements();
          Iterable<Formula> _filter_1 = Iterables.<Formula>filter(_conditionGraphElements_1, Formula.class);
          int _size_1 = IterableExtensions.size(_filter_1);
          boolean _greaterThan_1 = (_size_1 > 0);
          if (_greaterThan_1) {
            EList<GraphElements> _graphElements_1 = graph.getGraphElements();
            Iterable<Node> _filter_2 = Iterables.<Node>filter(_graphElements_1, Node.class);
            this.checkRekursiveOverrideNodeNamesinConditionGraph(_filter_2, topConNodes, conGraph);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn ein ConditionGraph einen Knoten eines darüberliegenden Graphen überschreibt
   * 
   * @param topNodes Liste der darüberliegenden Graphknoten
   * @param topConNodes Liste der darüberliegenden ConditionGraphknoten
   * @param graph Zu überprüfender Graph
   */
  private void checkRekursiveOverrideNodeNamesinConditionGraph(final Iterable<Node> topNodes, final List<ConditionNode> topConNodes, final ConditionGraph graph) {
    EList<ConditionGraphElements> _conditionGraphElements = graph.getConditionGraphElements();
    Iterable<Formula> formula = Iterables.<Formula>filter(_conditionGraphElements, Formula.class);
    int _size = IterableExtensions.size(formula);
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      final Iterable<Formula> _converted_formula = (Iterable<Formula>)formula;
      Formula _get = ((Formula[])Conversions.unwrapArray(_converted_formula, Formula.class))[0];
      EList<ConditionGraph> _conditionGraphs = _get.getConditionGraphs();
      for (final ConditionGraph conGraph : _conditionGraphs) {
        {
          EList<ConditionGraphElements> _conditionGraphElements_1 = conGraph.getConditionGraphElements();
          Iterable<ConditionNode> _filter = Iterables.<ConditionNode>filter(_conditionGraphElements_1, ConditionNode.class);
          for (final ConditionNode conNode : _filter) {
            {
              EList<ConditionGraphElements> _conditionGraphElements_2 = graph.getConditionGraphElements();
              Iterable<ConditionNode> _filter_1 = Iterables.<ConditionNode>filter(_conditionGraphElements_2, ConditionNode.class);
              for (final ConditionNode node : _filter_1) {
                String _name = conNode.getName();
                String _name_1 = node.getName();
                boolean _equals = Objects.equal(_name, _name_1);
                if (_equals) {
                  String _name_2 = conNode.getName();
                  String _plus = ("Duplicate Node \'" + _name_2);
                  String _plus_1 = (_plus + "\'.\'");
                  EReference _conditionNode_Type = Henshin_textPackage.eINSTANCE.getConditionNode_Type();
                  this.error(_plus_1, conNode, _conditionNode_Type);
                }
              }
              for (final Node node_1 : topNodes) {
                String _name_3 = conNode.getName();
                String _name_4 = node_1.getName();
                boolean _equals_1 = Objects.equal(_name_3, _name_4);
                if (_equals_1) {
                  String _name_5 = conNode.getName();
                  String _plus_2 = ("Duplicate Node \'" + _name_5);
                  String _plus_3 = (_plus_2 + "\'.\'");
                  EReference _conditionNode_Type_1 = Henshin_textPackage.eINSTANCE.getConditionNode_Type();
                  this.error(_plus_3, conNode, _conditionNode_Type_1);
                }
              }
              for (final ConditionNode node_2 : topConNodes) {
                String _name_6 = conNode.getName();
                String _name_7 = node_2.getName();
                boolean _equals_2 = Objects.equal(_name_6, _name_7);
                if (_equals_2) {
                  String _name_8 = conNode.getName();
                  String _plus_4 = ("Duplicate Node \'" + _name_8);
                  String _plus_5 = (_plus_4 + "\'.\'");
                  EReference _conditionNode_Type_2 = Henshin_textPackage.eINSTANCE.getConditionNode_Type();
                  this.error(_plus_5, conNode, _conditionNode_Type_2);
                }
              }
              topConNodes.add(conNode);
            }
          }
          EList<ConditionGraphElements> _conditionGraphElements_2 = conGraph.getConditionGraphElements();
          Iterable<Formula> _filter_1 = Iterables.<Formula>filter(_conditionGraphElements_2, Formula.class);
          int _size_1 = IterableExtensions.size(_filter_1);
          boolean _greaterThan_1 = (_size_1 > 0);
          if (_greaterThan_1) {
            this.checkRekursiveOverrideNodeNamesinConditionGraph(topNodes, topConNodes, conGraph);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn eine Formula auf einen übergeordneten ConditionGraph verweist
   * 
   * @param formula Zu überprüfende Formula
   */
  @Check
  public void checkFormulaConditionGraphLevel(final Formula formula) {
    Logic _formula = formula.getFormula();
    ArrayList<ConditionGraph> _arrayList = new ArrayList<ConditionGraph>();
    ArrayList<ConditionGraph> formulaGraphs = this.findDuplicate(_formula, _arrayList);
    for (final ConditionGraph graph : formulaGraphs) {
      EList<ConditionGraph> _conditionGraphs = formula.getConditionGraphs();
      boolean _contains = _conditionGraphs.contains(graph);
      boolean _not = (!_contains);
      if (_not) {
        String _name = graph.getName();
        String _plus = ("ConditionGraph \'" + _name);
        String _plus_1 = (_plus + "\' does not exist.\'");
        this.error(_plus_1, formula, Henshin_textPackage.Literals.FORMULA__FORMULA);
      }
    }
  }
  
  /**
   * Durchsucht Formula nach ihren ConditionGraphen
   * 
   * @param formula Zu durchsuchende Formula
   */
  @Check
  public boolean checkConditionFormula(final Formula formula) {
    boolean _xblockexpression = false;
    {
      ArrayList<ConditionGraph> conditionGraphs = new ArrayList<ConditionGraph>();
      boolean _xifexpression = false;
      Logic _formula = formula.getFormula();
      if ((_formula instanceof ANDImpl)) {
        boolean _xblockexpression_1 = false;
        {
          Logic _formula_1 = formula.getFormula();
          Logic _left = ((ANDImpl) _formula_1).getLeft();
          ArrayList<ConditionGraph> _findDuplicate = this.findDuplicate(_left, conditionGraphs);
          conditionGraphs.addAll(_findDuplicate);
          Logic _formula_2 = formula.getFormula();
          Logic _right = ((ANDImpl) _formula_2).getRight();
          ArrayList<ConditionGraph> _findDuplicate_1 = this.findDuplicate(_right, conditionGraphs);
          _xblockexpression_1 = conditionGraphs.addAll(_findDuplicate_1);
        }
        _xifexpression = _xblockexpression_1;
      } else {
        boolean _xifexpression_1 = false;
        Logic _formula_1 = formula.getFormula();
        if ((_formula_1 instanceof ORorXORImpl)) {
          boolean _xblockexpression_2 = false;
          {
            Logic _formula_2 = formula.getFormula();
            Logic _left = ((ORorXORImpl) _formula_2).getLeft();
            ArrayList<ConditionGraph> _findDuplicate = this.findDuplicate(_left, conditionGraphs);
            conditionGraphs.addAll(_findDuplicate);
            Logic _formula_3 = formula.getFormula();
            Logic _right = ((ORorXORImpl) _formula_3).getRight();
            ArrayList<ConditionGraph> _findDuplicate_1 = this.findDuplicate(_right, conditionGraphs);
            _xblockexpression_2 = conditionGraphs.addAll(_findDuplicate_1);
          }
          _xifexpression_1 = _xblockexpression_2;
        } else {
          boolean _xifexpression_2 = false;
          Logic _formula_2 = formula.getFormula();
          if ((_formula_2 instanceof NotImpl)) {
            Logic _formula_3 = formula.getFormula();
            Logic _negation = ((NotImpl) _formula_3).getNegation();
            ArrayList<ConditionGraph> _findDuplicate = this.findDuplicate(_negation, conditionGraphs);
            _xifexpression_2 = conditionGraphs.addAll(_findDuplicate);
          }
          _xifexpression_1 = _xifexpression_2;
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  /**
   * Fehler wenn ein ConditionGraph mehrfach verwendet wurde
   * 
   * @param logic Zu untersuchender logischer Ausdruck
   * @param conditionGraphs List der bereits gefundenen ConditionGraphen
   * @return List der bereits gefundenen ConditionGraphen
   */
  private ArrayList<ConditionGraph> findDuplicate(final Logic logic, final ArrayList<ConditionGraph> conditionGraphs) {
    if ((logic instanceof ANDImpl)) {
      Logic _left = ((ANDImpl) logic).getLeft();
      ArrayList<ConditionGraph> _findDuplicate = this.findDuplicate(_left, conditionGraphs);
      conditionGraphs.addAll(_findDuplicate);
      Logic _right = ((ANDImpl) logic).getRight();
      ArrayList<ConditionGraph> _findDuplicate_1 = this.findDuplicate(_right, conditionGraphs);
      conditionGraphs.addAll(_findDuplicate_1);
    } else {
      if ((logic instanceof ORorXORImpl)) {
        Logic _left_1 = ((ORorXORImpl) logic).getLeft();
        ArrayList<ConditionGraph> _findDuplicate_2 = this.findDuplicate(_left_1, conditionGraphs);
        conditionGraphs.addAll(_findDuplicate_2);
        Logic _right_1 = ((ORorXORImpl) logic).getRight();
        ArrayList<ConditionGraph> _findDuplicate_3 = this.findDuplicate(_right_1, conditionGraphs);
        conditionGraphs.addAll(_findDuplicate_3);
      } else {
        if ((logic instanceof NotImpl)) {
          Logic _negation = ((NotImpl) logic).getNegation();
          ArrayList<ConditionGraph> _findDuplicate_4 = this.findDuplicate(_negation, conditionGraphs);
          conditionGraphs.addAll(_findDuplicate_4);
        } else {
          if ((logic instanceof ConditionGraphRef)) {
            ConditionGraph _conditionGraphRef = ((ConditionGraphRef) logic).getConditionGraphRef();
            boolean _contains = conditionGraphs.contains(_conditionGraphRef);
            if (_contains) {
              ConditionGraph _conditionGraphRef_1 = ((ConditionGraphRef) logic).getConditionGraphRef();
              String _name = _conditionGraphRef_1.getName();
              String _plus = ("Duplicate ConditionGraph \'" + _name);
              String _plus_1 = (_plus + "\'.\'");
              EReference _conditionGraphRef_ConditionGraphRef = Henshin_textPackage.eINSTANCE.getConditionGraphRef_ConditionGraphRef();
              this.error(_plus_1, ((ConditionGraphRef) logic), _conditionGraphRef_ConditionGraphRef);
            } else {
              ConditionGraph _conditionGraphRef_2 = ((ConditionGraphRef) logic).getConditionGraphRef();
              conditionGraphs.add(_conditionGraphRef_2);
            }
          }
        }
      }
    }
    return conditionGraphs;
  }
  
  /**
   * Fehler wenn ein ConditionNode wie ein ConditionReuseNode benannt wurde
   * 
   * @param  graph Zu überprüfender ConditionGraph
   */
  @Check
  public void checkConditionGraphReuseOwnNodes(final ConditionGraph graph) {
    EList<ConditionGraphElements> _conditionGraphElements = graph.getConditionGraphElements();
    Iterable<ConditionReuseNode> _filter = Iterables.<ConditionReuseNode>filter(_conditionGraphElements, ConditionReuseNode.class);
    for (final ConditionReuseNode reuse : _filter) {
      EList<ConditionGraphElements> _conditionGraphElements_1 = graph.getConditionGraphElements();
      Iterable<ConditionNode> _filter_1 = Iterables.<ConditionNode>filter(_conditionGraphElements_1, ConditionNode.class);
      for (final ConditionNode node : _filter_1) {
        ConditionNodeTypes _name = reuse.getName();
        String _name_1 = _name.getName();
        String _name_2 = node.getName();
        boolean _equals = Objects.equal(_name_1, _name_2);
        if (_equals) {
          EReference _conditionReuseNode_Name = Henshin_textPackage.eINSTANCE.getConditionReuseNode_Name();
          this.error("ConditionGraph cannot reuse its own nodes.\'", reuse, _conditionReuseNode_Name);
        }
      }
    }
  }
  
  /**
   * Fehler wenn ein Knoten mehrfach reused wird in einem Graphen
   * 
   * @param graph Zu überprüfender ConditionGraph
   */
  @Check
  public void checkConditionGraphMultiReuse(final ConditionGraph graph) {
    EList<ConditionGraphElements> _conditionGraphElements = graph.getConditionGraphElements();
    Iterable<ConditionReuseNode> reuseNodes = Iterables.<ConditionReuseNode>filter(_conditionGraphElements, ConditionReuseNode.class);
    for (int i = 0; (i < IterableExtensions.size(reuseNodes)); i++) {
      for (int j = (i + 1); (j < IterableExtensions.size(reuseNodes)); j++) {
        final Iterable<ConditionReuseNode> _converted_reuseNodes = (Iterable<ConditionReuseNode>)reuseNodes;
        ConditionReuseNode _get = ((ConditionReuseNode[])Conversions.unwrapArray(_converted_reuseNodes, ConditionReuseNode.class))[i];
        ConditionNodeTypes _name = _get.getName();
        String _name_1 = _name.getName();
        final Iterable<ConditionReuseNode> _converted_reuseNodes_1 = (Iterable<ConditionReuseNode>)reuseNodes;
        ConditionReuseNode _get_1 = ((ConditionReuseNode[])Conversions.unwrapArray(_converted_reuseNodes_1, ConditionReuseNode.class))[j];
        ConditionNodeTypes _name_2 = _get_1.getName();
        String _name_3 = _name_2.getName();
        boolean _equals = Objects.equal(_name_1, _name_3);
        if (_equals) {
          final Iterable<ConditionReuseNode> _converted_reuseNodes_2 = (Iterable<ConditionReuseNode>)reuseNodes;
          ConditionReuseNode _get_2 = ((ConditionReuseNode[])Conversions.unwrapArray(_converted_reuseNodes_2, ConditionReuseNode.class))[j];
          ConditionNodeTypes _name_4 = _get_2.getName();
          String _name_5 = _name_4.getName();
          String _plus = (_name_5 + " is already reused in ConditionGraph ");
          String _name_6 = graph.getName();
          String _plus_1 = (_plus + _name_6);
          String _plus_2 = (_plus_1 + ".\'");
          final Iterable<ConditionReuseNode> _converted_reuseNodes_3 = (Iterable<ConditionReuseNode>)reuseNodes;
          EObject _get_3 = ((EObject[])Conversions.unwrapArray(_converted_reuseNodes_3, EObject.class))[j];
          EReference _conditionReuseNode_Name = Henshin_textPackage.eINSTANCE.getConditionReuseNode_Name();
          this.error(_plus_2, _get_3, _conditionReuseNode_Name);
        }
      }
    }
  }
  
  /**
   * Fehler bei einer negativen Anzahl an Iterationen
   * 
   * @param unit IteratedUnit die überprüft werden soll
   */
  @Check
  public void checkIterationUnitIterationsNegative(final IteratedUnit unit) {
    Expression _iterations = unit.getIterations();
    if ((_iterations instanceof NumberValue)) {
      Expression _iterations_1 = unit.getIterations();
      String _value = ((NumberValue) _iterations_1).getValue();
      boolean _contains = _value.contains("-");
      if (_contains) {
        EReference _iteratedUnit_Iterations = Henshin_textPackage.eINSTANCE.getIteratedUnit_Iterations();
        this.error("Negative values are not allowed.\'", unit, _iteratedUnit_Iterations);
      }
    } else {
      Expression _iterations_2 = unit.getIterations();
      if ((_iterations_2 instanceof IntegerValue)) {
        Expression _iterations_3 = unit.getIterations();
        String _value_1 = ((IntegerValue) _iterations_3).getValue();
        boolean _contains_1 = _value_1.contains("-");
        if (_contains_1) {
          EReference _iteratedUnit_Iterations_1 = Henshin_textPackage.eINSTANCE.getIteratedUnit_Iterations();
          this.error("Negative values are not allowed.\'", unit, _iteratedUnit_Iterations_1);
        }
      }
    }
  }
  
  /**
   * Fehler bei einem nicht-numerischen Parametertyp für Iterationen
   * 
   * @param unit IteratedUnit die überprüft werden soll
   */
  @Check
  public void checkIterationUnitIterationsType(final IteratedUnit unit) {
    Expression _iterations = unit.getIterations();
    boolean _notEquals = (!Objects.equal(_iterations, null));
    if (_notEquals) {
      Expression _iterations_1 = unit.getIterations();
      Henshin_textType _typeFor = this._henshin_textTypeProvider.typeFor(_iterations_1);
      String _string = _typeFor.toString();
      boolean _notEquals_1 = (!Objects.equal(_string, "number"));
      if (_notEquals_1) {
        Expression _iterations_2 = unit.getIterations();
        Henshin_textType _typeFor_1 = this._henshin_textTypeProvider.typeFor(_iterations_2);
        String _plus = ("IteratedUnit expected number type, but was " + _typeFor_1);
        String _plus_1 = (_plus + ".\'");
        EReference _iteratedUnit_Iterations = Henshin_textPackage.eINSTANCE.getIteratedUnit_Iterations();
        this.error(_plus_1, unit, _iteratedUnit_Iterations);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Strict-Element in einer Unit-Definition definiert wurde
   * 
   * @param unit Zu überprüfende Unit
   */
  @Check
  public void checkCountStrict(final Unit unit) {
    EList<UnitElement> _unitElements = unit.getUnitElements();
    Iterable<StrictImpl> iterableOfStrictImpl = Iterables.<StrictImpl>filter(_unitElements, StrictImpl.class);
    int _size = IterableExtensions.size(iterableOfStrictImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final StrictImpl strict : iterableOfStrictImpl) {
        this.error("Strict can only be used once.\'", strict, Henshin_textPackage.Literals.STRICT__STRICT);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Strict-Element in einer SubSequenz definiert wurde
   * 
   * @param unit Zu überprüfende SubSequenz
   */
  @Check
  public void checkCountStrictSubSequence(final UnitElement unit) {
    EList<UnitElement> _subSequence = unit.getSubSequence();
    Iterable<StrictImpl> iterableOfStrictImpl = Iterables.<StrictImpl>filter(_subSequence, StrictImpl.class);
    int _size = IterableExtensions.size(iterableOfStrictImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final StrictImpl strict : iterableOfStrictImpl) {
        this.error("Strict can only be used once.\'", strict, Henshin_textPackage.Literals.STRICT__STRICT);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Strict-Element in einer IndependentUnit definiert wurde
   * 
   * @param unit Zu überprüfende IndependentUnit
   */
  @Check
  public void checkCountStrictIndependentUnit(final IndependentUnit unit) {
    EList<org.eclipse.emf.henshin.text.henshin_text.List> _listOfLists = unit.getListOfLists();
    for (final org.eclipse.emf.henshin.text.henshin_text.List e : _listOfLists) {
      {
        EList<UnitElement> _subElements = e.getSubElements();
        Iterable<StrictImpl> iterableOfStrictImpl = Iterables.<StrictImpl>filter(_subElements, StrictImpl.class);
        int _size = IterableExtensions.size(iterableOfStrictImpl);
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final StrictImpl strict : iterableOfStrictImpl) {
            this.error("Strict can only be used once.\'", strict, Henshin_textPackage.Literals.STRICT__STRICT);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Strict-Element in einer ConditionalUnit definiert wurde
   * 
   * @param unit Zu überprüfende ConditionalUnit
   */
  @Check
  public void checkCountStrictConditionalUnit(final ConditionalUnit unit) {
    EList<UnitElement> _if = unit.getIf();
    Iterable<StrictImpl> iterableOfStrictImplIF = Iterables.<StrictImpl>filter(_if, StrictImpl.class);
    EList<UnitElement> _then = unit.getThen();
    Iterable<StrictImpl> iterableOfStrictImplTHEN = Iterables.<StrictImpl>filter(_then, StrictImpl.class);
    EList<UnitElement> _else = unit.getElse();
    Iterable<StrictImpl> iterableOfStrictImplELSE = Iterables.<StrictImpl>filter(_else, StrictImpl.class);
    int _size = IterableExtensions.size(iterableOfStrictImplIF);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final StrictImpl strict : iterableOfStrictImplIF) {
        this.error("Strict can only be used once.\'", strict, Henshin_textPackage.Literals.STRICT__STRICT);
      }
    }
    int _size_1 = IterableExtensions.size(iterableOfStrictImplTHEN);
    boolean _greaterThan_1 = (_size_1 > 1);
    if (_greaterThan_1) {
      for (final StrictImpl strict_1 : iterableOfStrictImplTHEN) {
        this.error("Strict can only be used once.\'", strict_1, Henshin_textPackage.Literals.STRICT__STRICT);
      }
    }
    int _size_2 = IterableExtensions.size(iterableOfStrictImplELSE);
    boolean _greaterThan_2 = (_size_2 > 1);
    if (_greaterThan_2) {
      for (final StrictImpl strict_2 : iterableOfStrictImplELSE) {
        this.error("Strict can only be used once.\'", strict_2, Henshin_textPackage.Literals.STRICT__STRICT);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Strict-Element in einer PriorityUnit definiert wurde
   * 
   * @param unit Zu überprüfende PriorityUnit
   */
  @Check
  public void checkCountStrictPriorityUnit(final PriorityUnit unit) {
    EList<org.eclipse.emf.henshin.text.henshin_text.List> _listOfLists = unit.getListOfLists();
    for (final org.eclipse.emf.henshin.text.henshin_text.List e : _listOfLists) {
      {
        EList<UnitElement> _subElements = e.getSubElements();
        Iterable<StrictImpl> iterableOfStrictImpl = Iterables.<StrictImpl>filter(_subElements, StrictImpl.class);
        int _size = IterableExtensions.size(iterableOfStrictImpl);
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final StrictImpl strict : iterableOfStrictImpl) {
            this.error("Strict can only be used once.\'", strict, Henshin_textPackage.Literals.STRICT__STRICT);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Strict-Element in einer IteratedUnit definiert wurde
   * 
   * @param unit Zu überprüfende IteratedUnit
   */
  @Check
  public void checkCountStrictIteratedUnit(final IteratedUnit unit) {
    EList<UnitElement> _subElement = unit.getSubElement();
    Iterable<StrictImpl> iterableOfStrictImpl = Iterables.<StrictImpl>filter(_subElement, StrictImpl.class);
    int _size = IterableExtensions.size(iterableOfStrictImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final StrictImpl strict : iterableOfStrictImpl) {
        this.error("Strict can only be used once.\'", strict, Henshin_textPackage.Literals.STRICT__STRICT);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Strict-Element in einer LoopUnit definiert wurde
   * 
   * @param unit Zu überprüfende LoopUnit
   */
  @Check
  public void checkCountStrictLoopUnit(final LoopUnit unit) {
    EList<UnitElement> _subElement = unit.getSubElement();
    Iterable<StrictImpl> iterableOfStrictImpl = Iterables.<StrictImpl>filter(_subElement, StrictImpl.class);
    int _size = IterableExtensions.size(iterableOfStrictImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final StrictImpl strict : iterableOfStrictImpl) {
        this.error("Strict can only be used once.\'", strict, Henshin_textPackage.Literals.STRICT__STRICT);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Rollback-Element in einer Unit-Definition definiert wurde
   * 
   * @param unit Zu überprüfende Unit
   */
  @Check
  public void checkCountRollback(final Unit unit) {
    EList<UnitElement> _unitElements = unit.getUnitElements();
    Iterable<RollbackImpl> iterableOfRollbackImpl = Iterables.<RollbackImpl>filter(_unitElements, RollbackImpl.class);
    int _size = IterableExtensions.size(iterableOfRollbackImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final RollbackImpl rollback : iterableOfRollbackImpl) {
        this.error("Rollback can only be used once.\'", rollback, Henshin_textPackage.Literals.ROLLBACK__ROLLBACK);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Rollback-Element in einer SubSequenz definiert wurde
   * 
   * @param unit Zu überprüfende SupSequenz
   */
  @Check
  public void checkCountRollbackSubSequence(final UnitElement unit) {
    EList<UnitElement> _subSequence = unit.getSubSequence();
    Iterable<RollbackImpl> iterableOfRollbackImpl = Iterables.<RollbackImpl>filter(_subSequence, RollbackImpl.class);
    int _size = IterableExtensions.size(iterableOfRollbackImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final RollbackImpl rollback : iterableOfRollbackImpl) {
        this.error("Rollback can only be used once.\'", rollback, Henshin_textPackage.Literals.ROLLBACK__ROLLBACK);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Rollback-Element in einer IndependentUnit definiert wurde
   * 
   * @param unit Zu überprüfende IndependentUnit
   */
  @Check
  public void checkCountRollbackIndependentUnit(final IndependentUnit unit) {
    EList<org.eclipse.emf.henshin.text.henshin_text.List> _listOfLists = unit.getListOfLists();
    for (final org.eclipse.emf.henshin.text.henshin_text.List e : _listOfLists) {
      {
        EList<UnitElement> _subElements = e.getSubElements();
        Iterable<RollbackImpl> iterableOfRollbackImpl = Iterables.<RollbackImpl>filter(_subElements, RollbackImpl.class);
        int _size = IterableExtensions.size(iterableOfRollbackImpl);
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final RollbackImpl rollback : iterableOfRollbackImpl) {
            this.error("Rollback can only be used once.\'", rollback, Henshin_textPackage.Literals.ROLLBACK__ROLLBACK);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Rollback-Element in einer ConditionalUnit definiert wurde
   * 
   * @param unit Zu überprüfende ConditionalUnit
   */
  @Check
  public void checkCountRollbackConditionalUnit(final ConditionalUnit unit) {
    EList<UnitElement> _if = unit.getIf();
    Iterable<RollbackImpl> iterableOfRollbackImplIF = Iterables.<RollbackImpl>filter(_if, RollbackImpl.class);
    EList<UnitElement> _then = unit.getThen();
    Iterable<RollbackImpl> iterableOfRollbackImplTHEN = Iterables.<RollbackImpl>filter(_then, RollbackImpl.class);
    EList<UnitElement> _else = unit.getElse();
    Iterable<RollbackImpl> iterableOfRollbackImplELSE = Iterables.<RollbackImpl>filter(_else, RollbackImpl.class);
    int _size = IterableExtensions.size(iterableOfRollbackImplIF);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final RollbackImpl rollback : iterableOfRollbackImplIF) {
        this.error("Strict can only be used once.\'", rollback, Henshin_textPackage.Literals.ROLLBACK__ROLLBACK);
      }
    }
    int _size_1 = IterableExtensions.size(iterableOfRollbackImplTHEN);
    boolean _greaterThan_1 = (_size_1 > 1);
    if (_greaterThan_1) {
      for (final RollbackImpl rollback_1 : iterableOfRollbackImplTHEN) {
        this.error("Strict can only be used once.\'", rollback_1, Henshin_textPackage.Literals.ROLLBACK__ROLLBACK);
      }
    }
    int _size_2 = IterableExtensions.size(iterableOfRollbackImplELSE);
    boolean _greaterThan_2 = (_size_2 > 1);
    if (_greaterThan_2) {
      for (final RollbackImpl rollback_2 : iterableOfRollbackImplELSE) {
        this.error("Strict can only be used once.\'", rollback_2, Henshin_textPackage.Literals.ROLLBACK__ROLLBACK);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Rollback-Element in einer PriorityUnit definiert wurde
   * 
   * @param unit Zu überprüfende PriorityUnit
   */
  @Check
  public void checkCountRollbackPriorityUnit(final PriorityUnit unit) {
    EList<org.eclipse.emf.henshin.text.henshin_text.List> _listOfLists = unit.getListOfLists();
    for (final org.eclipse.emf.henshin.text.henshin_text.List e : _listOfLists) {
      {
        EList<UnitElement> _subElements = e.getSubElements();
        Iterable<RollbackImpl> iterableOfRollbackImpl = Iterables.<RollbackImpl>filter(_subElements, RollbackImpl.class);
        int _size = IterableExtensions.size(iterableOfRollbackImpl);
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final RollbackImpl rollback : iterableOfRollbackImpl) {
            this.error("Rollback can only be used once.\'", rollback, Henshin_textPackage.Literals.ROLLBACK__ROLLBACK);
          }
        }
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Rollback-Element in einer IteratedUnit definiert wurde
   * 
   * @param unit Zu überprüfende IteratedUnit
   */
  @Check
  public void checkCountRollbackIteratedUnit(final IteratedUnit unit) {
    EList<UnitElement> _subElement = unit.getSubElement();
    Iterable<RollbackImpl> iterableOfRollbackImpl = Iterables.<RollbackImpl>filter(_subElement, RollbackImpl.class);
    int _size = IterableExtensions.size(iterableOfRollbackImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final RollbackImpl rollback : iterableOfRollbackImpl) {
        this.error("Rollback can only be used once.\'", rollback, Henshin_textPackage.Literals.ROLLBACK__ROLLBACK);
      }
    }
  }
  
  /**
   * Fehler wenn mehr als ein Rollback-Element in einer LoopUnit definiert wurde
   * 
   * @param unit Zu überprüfende LoopUnit
   */
  @Check
  public void checkCountRollbackLoopUnit(final LoopUnit unit) {
    EList<UnitElement> _subElement = unit.getSubElement();
    Iterable<RollbackImpl> iterableOfRollbackImpl = Iterables.<RollbackImpl>filter(_subElement, RollbackImpl.class);
    int _size = IterableExtensions.size(iterableOfRollbackImpl);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final RollbackImpl rollback : iterableOfRollbackImpl) {
        this.error("Rollback can only be used once.\'", rollback, Henshin_textPackage.Literals.ROLLBACK__ROLLBACK);
      }
    }
  }
  
  /**
   * Fehler wenn NOT auf einen anderen Wert als vom Typ Boolean angewendet wird
   * 
   * @param not Zu überprüfender NOT-Ausdruck
   */
  @Check
  public void checkTypeNot(final NotExpression not) {
    Expression _expression = not.getExpression();
    this.checkExpectedType(_expression, Henshin_textTypeProvider.boolType, Henshin_textPackage.Literals.NOT_EXPRESSION__EXPRESSION);
  }
  
  /**
   * Fehler wenn keine Zahlenwerte in einem Multiplikations-/Divisions-Ausdruck verwendet werden
   * 
   * @param plus Zu überprüfender Multiplikations-/Divisions-Ausdruck
   */
  @Check
  public void checkTypeMulOrDiv(final MulOrDivExpression mulOrDiv) {
    Expression _left = mulOrDiv.getLeft();
    this.checkExpectedType(_left, Henshin_textTypeProvider.numberType, Henshin_textPackage.Literals.MUL_OR_DIV_EXPRESSION__LEFT);
    Expression _right = mulOrDiv.getRight();
    this.checkExpectedType(_right, Henshin_textTypeProvider.numberType, Henshin_textPackage.Literals.MUL_OR_DIV_EXPRESSION__RIGHT);
  }
  
  /**
   * Fehler wenn keine Zahlenwerte in einem Subtraktions-Ausdruck verwendet werden
   * 
   * @param plus Zu überprüfender Subtraktions-Ausdruck
   */
  @Check
  public void checkTypeMinus(final MinusExpression minus) {
    Expression _left = minus.getLeft();
    this.checkExpectedType(_left, Henshin_textTypeProvider.numberType, Henshin_textPackage.Literals.MINUS_EXPRESSION__LEFT);
    Expression _right = minus.getRight();
    this.checkExpectedType(_right, Henshin_textTypeProvider.numberType, Henshin_textPackage.Literals.MINUS_EXPRESSION__RIGHT);
  }
  
  /**
   * Fehler wenn keine Zahlenwerte miteinander addiert werden sollen
   * 
   * @param plus Zu überprüfender Additions-Ausdruck
   */
  @Check
  public void checkTypePlus(final PlusExpression plus) {
    Expression _left = plus.getLeft();
    this.checkExpectedType(_left, Henshin_textTypeProvider.numberType, Henshin_textPackage.Literals.PLUS_EXPRESSION__LEFT);
    Expression _right = plus.getRight();
    this.checkExpectedType(_right, Henshin_textTypeProvider.numberType, Henshin_textPackage.Literals.PLUS_EXPRESSION__RIGHT);
  }
  
  /**
   * Fehler wenn keine Boolean-Werte in einem AND-Ausdruck verwendet werden
   * 
   * @param and Zu überprüfender AND-Ausdruck
   */
  @Check
  public void checkTypeAnd(final AndExpression and) {
    Expression _left = and.getLeft();
    this.checkExpectedType(_left, Henshin_textTypeProvider.boolType, Henshin_textPackage.Literals.AND_EXPRESSION__LEFT);
    Expression _right = and.getRight();
    this.checkExpectedType(_right, Henshin_textTypeProvider.boolType, Henshin_textPackage.Literals.AND_EXPRESSION__RIGHT);
  }
  
  /**
   * Fehler wenn keine Boolean-Werte in einem OR-Ausdruck verwendet werden
   * 
   * @param or Zu überprüfender OR-Ausdruck
   */
  @Check
  public void checkTypeOr(final OrExpression or) {
    Expression _left = or.getLeft();
    this.checkExpectedType(_left, Henshin_textTypeProvider.boolType, Henshin_textPackage.Literals.OR_EXPRESSION__LEFT);
    Expression _right = or.getRight();
    this.checkExpectedType(_right, Henshin_textTypeProvider.boolType, Henshin_textPackage.Literals.OR_EXPRESSION__RIGHT);
  }
  
  /**
   * Fehler wenn Werte unterschiedlicher Typen auf Un-/Gleichheit geprüft werden
   * 
   * @param equality Zu überprüfender Un-/Gleichheits-Ausdruck
   */
  @Check
  public void checkTypeEquality(final EqualityExpression equality) {
    Expression _left = equality.getLeft();
    final Henshin_textType leftType = this.getTypeAndCheckNotNull(_left, Henshin_textPackage.Literals.EQUALITY_EXPRESSION__LEFT);
    Expression _right = equality.getRight();
    final Henshin_textType rightType = this.getTypeAndCheckNotNull(_right, Henshin_textPackage.Literals.EQUALITY_EXPRESSION__RIGHT);
    if ((((!Objects.equal(leftType, rightType)) && (!Objects.equal(leftType, null))) && (!Objects.equal(rightType, null)))) {
      EAttribute _eIDAttribute = Henshin_textPackage.Literals.EQUALITY_EXPRESSION.getEIDAttribute();
      this.error((((("Expression expected the same type, but was " + leftType) + " and ") + rightType) + ".\'"), _eIDAttribute, "");
    }
  }
  
  /**
   * Fehler wenn bei einem Verleich unterschiedliche Typen oder Boolean-Werte miteinander verglichen werden
   * 
   * @param comparison Zu überprüfender Vergleichs-Ausdruck
   */
  @Check
  public void checkTypeComparison(final ComparisonExpression comparison) {
    Expression _left = comparison.getLeft();
    final Henshin_textType leftType = this.getTypeAndCheckNotNull(_left, Henshin_textPackage.Literals.COMPARISON_EXPRESSION__LEFT);
    Expression _right = comparison.getRight();
    final Henshin_textType rightType = this.getTypeAndCheckNotNull(_right, Henshin_textPackage.Literals.COMPARISON_EXPRESSION__RIGHT);
    if ((((!Objects.equal(leftType, rightType)) && (!Objects.equal(leftType, null))) && (!Objects.equal(rightType, null)))) {
      EAttribute _eIDAttribute = Henshin_textPackage.Literals.COMPARISON_EXPRESSION.getEIDAttribute();
      this.error((((("Expression expected the same type, but was " + leftType) + " and ") + rightType) + ".\'"), _eIDAttribute, "");
    }
    if ((Objects.equal(leftType, Henshin_textTypeProvider.boolType) || Objects.equal(leftType, Henshin_textTypeProvider.complexType))) {
      this.error("Value cannot be compared.\'", Henshin_textPackage.Literals.COMPARISON_EXPRESSION__LEFT, "");
    }
    if ((Objects.equal(rightType, Henshin_textTypeProvider.boolType) || Objects.equal(leftType, Henshin_textTypeProvider.complexType))) {
      this.error("Value cannot be compared.\'", Henshin_textPackage.Literals.COMPARISON_EXPRESSION__RIGHT, "");
    }
  }
  
  /**
   * Fehler wenn der tatsächliche Typ eines Ausdrucks nicht zur erwarteten Typart passt.
   * 
   * @param expression Zu überprüfender Ausdruck
   * @param expectedType Erwarteter Typ
   * @param reference Referenz zum zu überprüfenden Ausdrucks
   */
  private void checkExpectedType(final Expression expression, final Henshin_textType expectedType, final EReference reference) {
    final Henshin_textType actualType = this.getTypeAndCheckNotNull(expression, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error((((("Expression expected " + expectedType) + " type, but was ") + actualType) + ".\'"), reference, "");
    }
  }
  
  /**
   * Liefert die Typart eines Ausdrucks zurück. Fehler wenn keine passende Typart gefunden wurde.
   * 
   * @param expression Zu überprüfender Ausdruck
   * @param refrence Referenz zum zu überprüfenden Ausdrucks
   * 
   * @return Typart des Ausdrucks
   */
  private Henshin_textType getTypeAndCheckNotNull(final Expression expression, final EReference reference) {
    Henshin_textType type = null;
    boolean _notEquals = (!Objects.equal(expression, null));
    if (_notEquals) {
      Henshin_textType _typeFor = this._henshin_textTypeProvider.typeFor(expression);
      type = _typeFor;
    }
    boolean _equals = Objects.equal(type, null);
    if (_equals) {
      this.error("Null type.\'", reference, "");
    }
    return type;
  }
  
  /**
   * Fehler wenn ein Ausdruck einem Attribut zugewiesen wird der den falschen Typ hat
   * 
   * @param attribute Zu überprüfendes Attribut
   */
  @Check
  public void checkAttributeType(final Attribute attribute) {
    Expression _value = attribute.getValue();
    if ((_value instanceof ParameterValue)) {
      if (((!Objects.equal(((ParameterValue) attribute.getValue()).getValue().getType().getType(), null)) && (!Objects.equal(attribute.getName().getEAttributeType().getName(), ((ParameterValue) attribute.getValue()).getValue().getType().getType().getName())))) {
        EAttribute _name = attribute.getName();
        EDataType _eAttributeType = _name.getEAttributeType();
        String _name_1 = _eAttributeType.getName();
        String _plus = ("Attribute expected " + _name_1);
        String _plus_1 = (_plus + " type, but was ");
        Expression _value_1 = attribute.getValue();
        Parameter _value_2 = ((ParameterValue) _value_1).getValue();
        ParameterType _type = _value_2.getType();
        EClass _type_1 = _type.getType();
        String _name_2 = _type_1.getName();
        String _plus_2 = (_plus_1 + _name_2);
        String _plus_3 = (_plus_2 + ".\'");
        EReference _attribute_Value = Henshin_textPackage.eINSTANCE.getAttribute_Value();
        this.error(_plus_3, attribute, _attribute_Value);
      } else {
        if (((!Objects.equal(this._henshin_textTypeProvider.typeFor(attribute.getName().getEAttributeType().getName()).toString(), "string")) && (!Objects.equal(this._henshin_textTypeProvider.typeFor(attribute.getName().getEAttributeType().getName()), this._henshin_textTypeProvider.typeFor(((ParameterValue) attribute.getValue()).getValue().getType().getEnumType().getLiteral()))))) {
          EAttribute _name_3 = attribute.getName();
          EDataType _eAttributeType_1 = _name_3.getEAttributeType();
          String _name_4 = _eAttributeType_1.getName();
          String _plus_4 = ("Attribute expected " + _name_4);
          String _plus_5 = (_plus_4 + " type, but was ");
          Expression _value_3 = attribute.getValue();
          Parameter _value_4 = ((ParameterValue) _value_3).getValue();
          ParameterType _type_2 = _value_4.getType();
          Type _enumType = _type_2.getEnumType();
          String _literal = _enumType.getLiteral();
          String _plus_6 = (_plus_5 + _literal);
          String _plus_7 = (_plus_6 + ".\'");
          EReference _attribute_Value_1 = Henshin_textPackage.eINSTANCE.getAttribute_Value();
          this.error(_plus_7, attribute, _attribute_Value_1);
        }
      }
    } else {
      if (((!Objects.equal(this._henshin_textTypeProvider.typeFor(attribute.getName().getEAttributeType().getName()).toString(), "string")) && (!Objects.equal(this._henshin_textTypeProvider.typeFor(attribute.getName().getEAttributeType().getName()), this._henshin_textTypeProvider.typeFor(attribute.getValue()))))) {
        EAttribute _name_5 = attribute.getName();
        EDataType _eAttributeType_2 = _name_5.getEAttributeType();
        String _name_6 = _eAttributeType_2.getName();
        String _plus_8 = ("Attribute expected " + _name_6);
        String _plus_9 = (_plus_8 + " type, but was ");
        Expression _value_5 = attribute.getValue();
        Henshin_textType _typeFor = this._henshin_textTypeProvider.typeFor(_value_5);
        String _plus_10 = (_plus_9 + _typeFor);
        String _plus_11 = (_plus_10 + ".\'");
        EReference _attribute_Value_2 = Henshin_textPackage.eINSTANCE.getAttribute_Value();
        this.error(_plus_11, attribute, _attribute_Value_2);
      }
    }
  }
  
  /**
   * Fehler wenn ein Ausdruck einem Match zugewiesen wird der den falschen Typ hat
   * 
   * @param match Zu überprüfender Match-Ausdruck
   */
  @Check
  public void checkMatchType(final Match match) {
    Expression _value = match.getValue();
    if ((_value instanceof ParameterValue)) {
      if (((!Objects.equal(((ParameterValue) match.getValue()).getValue().getType().getType(), null)) && (!Objects.equal(match.getName().getEAttributeType().getName(), ((ParameterValue) match.getValue()).getValue().getType().getType().getName())))) {
        EAttribute _name = match.getName();
        EDataType _eAttributeType = _name.getEAttributeType();
        String _name_1 = _eAttributeType.getName();
        String _plus = ("Attribute expected " + _name_1);
        String _plus_1 = (_plus + " type, but was ");
        Expression _value_1 = match.getValue();
        Parameter _value_2 = ((ParameterValue) _value_1).getValue();
        ParameterType _type = _value_2.getType();
        EClass _type_1 = _type.getType();
        String _name_2 = _type_1.getName();
        String _plus_2 = (_plus_1 + _name_2);
        String _plus_3 = (_plus_2 + ".\'");
        EReference _match_Value = Henshin_textPackage.eINSTANCE.getMatch_Value();
        this.error(_plus_3, match, _match_Value);
      } else {
        if (((!Objects.equal(this._henshin_textTypeProvider.typeFor(match.getName().getEAttributeType().getName()).toString(), "string")) && (!Objects.equal(this._henshin_textTypeProvider.typeFor(match.getName().getEAttributeType().getName()), this._henshin_textTypeProvider.typeFor(((ParameterValue) match.getValue()).getValue().getType().getEnumType().getLiteral()))))) {
          EAttribute _name_3 = match.getName();
          EDataType _eAttributeType_1 = _name_3.getEAttributeType();
          String _name_4 = _eAttributeType_1.getName();
          String _plus_4 = ("Attribute expected " + _name_4);
          String _plus_5 = (_plus_4 + " type, but was ");
          Expression _value_3 = match.getValue();
          Parameter _value_4 = ((ParameterValue) _value_3).getValue();
          ParameterType _type_2 = _value_4.getType();
          Type _enumType = _type_2.getEnumType();
          String _literal = _enumType.getLiteral();
          String _plus_6 = (_plus_5 + _literal);
          String _plus_7 = (_plus_6 + ".\'");
          EReference _match_Value_1 = Henshin_textPackage.eINSTANCE.getMatch_Value();
          this.error(_plus_7, match, _match_Value_1);
        }
      }
    } else {
      if (((!Objects.equal(this._henshin_textTypeProvider.typeFor(match.getName().getEAttributeType().getName()).toString(), "string")) && (!Objects.equal(this._henshin_textTypeProvider.typeFor(match.getName().getEAttributeType().getName()), this._henshin_textTypeProvider.typeFor(match.getValue()))))) {
        EAttribute _name_5 = match.getName();
        EDataType _eAttributeType_2 = _name_5.getEAttributeType();
        String _name_6 = _eAttributeType_2.getName();
        String _plus_8 = ("Attribute expected " + _name_6);
        String _plus_9 = (_plus_8 + " type, but was ");
        Expression _value_5 = match.getValue();
        Henshin_textType _typeFor = this._henshin_textTypeProvider.typeFor(_value_5);
        String _plus_10 = (_plus_9 + _typeFor);
        String _plus_11 = (_plus_10 + ".\'");
        EReference _match_Value_2 = Henshin_textPackage.eINSTANCE.getMatch_Value();
        this.error(_plus_11, match, _match_Value_2);
      }
    }
  }
  
  /**
   * Fehler wenn das Java-Attribut nicht existiert
   * 
   * @param attribute Zu überprüfenders Java-Attribute
   */
  @Check
  public void checkJavaAttribute(final JavaAttributeValue attribute) {
    Iterable<JavaImport> iterableOfJavaImportImpl = this.getImportList(attribute);
    Field javaAttribute = null;
    for (final JavaImport imports : iterableOfJavaImportImpl) {
      try {
        String _packagename = imports.getPackagename();
        String _plus = (_packagename + ".");
        String _value = attribute.getValue();
        String[] _split = _value.split("\\.");
        String _get = _split[0];
        String _plus_1 = (_plus + _get);
        Class<?> calledClass = Class.forName(_plus_1);
        Field[] _declaredFields = calledClass.getDeclaredFields();
        for (final Field atrib : _declaredFields) {
          String _name = atrib.getName();
          String _value_1 = attribute.getValue();
          String[] _split_1 = _value_1.split("\\.");
          Object _get_1 = _split_1[1];
          boolean _equals = Objects.equal(_name, _get_1);
          if (_equals) {
            javaAttribute = atrib;
          }
        }
      } catch (final Throwable _t) {
        if (_t instanceof ClassNotFoundException) {
          final ClassNotFoundException e = (ClassNotFoundException)_t;
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
    }
    boolean _equals_1 = Objects.equal(javaAttribute, null);
    if (_equals_1) {
      String _value_2 = attribute.getValue();
      String _plus_2 = (_value_2 + " doesn\'t exist.\'");
      EAttribute _javaAttributeValue_Value = Henshin_textPackage.eINSTANCE.getJavaAttributeValue_Value();
      this.error(_plus_2, attribute, _javaAttributeValue_Value);
    }
  }
  
  /**
   * Fehler wenn die aufgerufene Java-Methode nicht existiert oder der Aufruf fehlerhaft ist
   * 
   * @param classCall Javamethodenaufruf der überprüft werden soll
   */
  @Check
  public void checkJavaCall(final JavaClassValue classCall) {
    Iterable<JavaImport> iterableOfJavaImportImpl = this.getImportList(classCall);
    List<Method> methods = new ArrayList<Method>();
    for (final JavaImport imports : iterableOfJavaImportImpl) {
      try {
        String _packagename = imports.getPackagename();
        String _plus = (_packagename + ".");
        String _value = classCall.getValue();
        String[] _split = _value.split("\\.");
        String _get = _split[0];
        String _plus_1 = (_plus + _get);
        Class<?> calledClass = Class.forName(_plus_1);
        Method[] _methods = calledClass.getMethods();
        for (final Method method : _methods) {
          String _name = method.getName();
          String _value_1 = classCall.getValue();
          String[] _split_1 = _value_1.split("\\.");
          Object _get_1 = _split_1[1];
          boolean _equals = Objects.equal(_name, _get_1);
          if (_equals) {
            methods.add(method);
          }
        }
      } catch (final Throwable _t) {
        if (_t instanceof ClassNotFoundException) {
          final ClassNotFoundException e = (ClassNotFoundException)_t;
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
    }
    int _size = methods.size();
    boolean _lessEqualsThan = (_size <= 0);
    if (_lessEqualsThan) {
      String _value_2 = classCall.getValue();
      String _plus_2 = (_value_2 + " doesn\'t exist.\'");
      EAttribute _javaClassValue_Value = Henshin_textPackage.eINSTANCE.getJavaClassValue_Value();
      this.error(_plus_2, classCall, _javaClassValue_Value);
    } else {
      boolean badParametercount = true;
      boolean wrongParameterType = false;
      boolean methodExist = false;
      for (final Method method_1 : methods) {
        if ((!methodExist)) {
          Class<?>[] _parameterTypes = method_1.getParameterTypes();
          int _size_1 = ((List<Class<?>>)Conversions.doWrapArray(_parameterTypes)).size();
          EList<Expression> _javaParameter = classCall.getJavaParameter();
          int _size_2 = _javaParameter.size();
          boolean _equals_1 = (_size_1 == _size_2);
          if (_equals_1) {
            badParametercount = false;
            for (int i = 0; (i < classCall.getJavaParameter().size()); i++) {
              EList<Expression> _javaParameter_1 = classCall.getJavaParameter();
              Expression _get_2 = _javaParameter_1.get(i);
              Henshin_textType _typeFor = this._henshin_textTypeProvider.typeFor(_get_2);
              Class<?>[] _parameterTypes_1 = method_1.getParameterTypes();
              Class<?> _get_3 = _parameterTypes_1[i];
              String _name_1 = _get_3.getName();
              Henshin_textType _typeForJavaType = this._henshin_textTypeProvider.typeForJavaType(_name_1);
              boolean _notEquals = (!Objects.equal(_typeFor, _typeForJavaType));
              if (_notEquals) {
                wrongParameterType = true;
              }
            }
          }
          if (((!badParametercount) && (!wrongParameterType))) {
            methodExist = true;
          } else {
            badParametercount = true;
            wrongParameterType = false;
          }
        }
      }
      if ((!methodExist)) {
        Method _get_2 = methods.get(0);
        Class<?>[] _parameterTypes_1 = _get_2.getParameterTypes();
        int _size_3 = ((List<Class<?>>)Conversions.doWrapArray(_parameterTypes_1)).size();
        EList<Expression> _javaParameter_1 = classCall.getJavaParameter();
        int _size_4 = _javaParameter_1.size();
        boolean _notEquals = (_size_3 != _size_4);
        if (_notEquals) {
          EAttribute _javaClassValue_Value_1 = Henshin_textPackage.eINSTANCE.getJavaClassValue_Value();
          this.error("Bad Parameter Count.\'", classCall, _javaClassValue_Value_1);
        } else {
          for (int i = 0; (i < classCall.getJavaParameter().size()); i++) {
            EList<Expression> _javaParameter_2 = classCall.getJavaParameter();
            Expression _get_3 = _javaParameter_2.get(i);
            Henshin_textType _typeFor = this._henshin_textTypeProvider.typeFor(_get_3);
            Method _get_4 = methods.get(0);
            Class<?>[] _parameterTypes_2 = _get_4.getParameterTypes();
            Class<?> _get_5 = _parameterTypes_2[i];
            String _name_1 = _get_5.getName();
            Henshin_textType _typeForJavaType = this._henshin_textTypeProvider.typeForJavaType(_name_1);
            boolean _notEquals_1 = (!Objects.equal(_typeFor, _typeForJavaType));
            if (_notEquals_1) {
              Method _get_6 = methods.get(0);
              Class<?>[] _parameterTypes_3 = _get_6.getParameterTypes();
              Class<?> _get_7 = _parameterTypes_3[i];
              String _name_2 = _get_7.getName();
              String _plus_3 = ("Methode expected " + _name_2);
              String _plus_4 = (_plus_3 + " type, but was ");
              EList<Expression> _javaParameter_3 = classCall.getJavaParameter();
              Expression _get_8 = _javaParameter_3.get(i);
              Henshin_textType _typeFor_1 = this._henshin_textTypeProvider.typeFor(_get_8);
              String _plus_5 = (_plus_4 + _typeFor_1);
              String _plus_6 = (_plus_5 + ".\'");
              EList<Expression> _javaParameter_4 = classCall.getJavaParameter();
              Expression _get_9 = _javaParameter_4.get(i);
              EReference _javaClassValue_JavaParameter = Henshin_textPackage.eINSTANCE.getJavaClassValue_JavaParameter();
              this.error(_plus_6, _get_9, _javaClassValue_JavaParameter);
            }
          }
        }
      }
    }
  }
  
  /**
   * Liefert Liste der importierten JavaPackages oberhalb des übergebenen Objekts
   * 
   * @param startObject Object für das alle JavaPackages gefunden werden soll
   * 
   * @return List<JavaImport> Liste der importierten JavaPackages
   */
  private List<JavaImport> getImportList(final EObject startObject) {
    List<JavaImport> iterableOfJavaImportImpl = new ArrayList<JavaImport>();
    EObject container = startObject.eContainer();
    while (((!(container instanceof Rule)) && (!(container instanceof MultiRule)))) {
      EObject _eContainer = container.eContainer();
      container = _eContainer;
    }
    if ((container instanceof Rule)) {
      EList<RuleElement> _ruleElements = ((Rule) container).getRuleElements();
      Iterable<JavaImport> _filter = Iterables.<JavaImport>filter(_ruleElements, JavaImport.class);
      Iterables.<JavaImport>addAll(iterableOfJavaImportImpl, _filter);
    } else {
      EList<RuleElement> _multiruleElements = ((MultiRule) container).getMultiruleElements();
      Iterable<JavaImport> _filter_1 = Iterables.<JavaImport>filter(_multiruleElements, JavaImport.class);
      Iterables.<JavaImport>addAll(iterableOfJavaImportImpl, _filter_1);
    }
    EObject _eContainer = container.eContainer();
    boolean _not = (!(_eContainer instanceof Model));
    if (_not) {
      List<JavaImport> _importList = this.getImportList(container);
      iterableOfJavaImportImpl.addAll(_importList);
    }
    return iterableOfJavaImportImpl;
  }
}
