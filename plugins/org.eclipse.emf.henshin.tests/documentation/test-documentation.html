<html>
<head>
<title>Henshin test documentation</title>
<style type="text/css">
h1 {background-color: rgb(250, 250, 10); border: 1px solid rgb(180, 180, 120);}
h2 {background-color: rgb(245, 245, 225); border: 1px solid rgb(120, 150, 150);}
h3 {background-color: rgb(245, 245, 235);}
body {background-color: rgb(255, 255, 250); font-family: sans-serif; padding-left: 1em;}
</style>
</head>
<body>
<h1>About this document</h1>
<p>This document describes all currently implemented JUnit tests for henshin. Tests are roughly grouped by the feature tested. Whenever possible, the model graphs on which henshin's graph transformations are executed is shown as a picture to ease understanding the transformations.<p>
<p>Features of particular interest (e.g. created nodes) are highlighted in blue <span style="border: 2px solid rgb(96, 185, 222);">like this</span>. Where relevant, edges have been annotated. Please note all models contain a containment node (cont) which has edges to all other objects. In most pictures in this documentation, the containment node and its edges have been hidden to achieve a clutter-free visual representation.
</p>
<h1>The test model</h1>
<p>The test model has been specifically designed to use typical features one might find in real-world models.
It contains unidirectional and bidirectional edges as well as 1:1, 1:n and n:m edges.<br />
There are three classes in the model: <em>cont</em> is the containment class used for serialization. <em>Node</em> models a node and has a single attribute, nodename. <em>Val</em> models a value, and has two attributes: Its name valname and its value intvl.<br />
The test model can be used to model tree structures; each <em>Node</em> may have one parent and a number of children. This is modelled as a bidirectional edge. Additionaly, <em>Node</em>s can have (edges to) <em>Val</em>s.<br />
<img src="img/ecoremodel.png" />
</p>

<h1>Matching engine tests</h1>
<p>14 tests</p>
<p>These tests test various aspects of the matching engine. 
All tests are implemented in <span class="classname">MatchTests.java</span>, all graphs used can be found in <span class="graph">matchTestsModels</span>. The associated henshin rule file is <span class="henshin">basicMatchingTests.henshin</span>.</p>

<h3>testACMatchNoNodes</h3>
<ul>
<li>Graph used: manyNodes</li>
<li>Rule used: acMatchNoNode</li>
</ul>
<img src="img/testMatchNoNodes.png" />
<p>
In this test, no nodes should be matched. The rule's left-hand side (LHS) and negative application condition (NAC) are identical, so there should not be any match in any case.
</p>

<h3>testMatchAllNodes</h3>
<ul>
<li>Graph used: manyNodes</li>
<li>Rule used: matchAllNodes</li>
</ul>
<img src="img/testMatchAllNodes.png" />
<p>In this test, all <em>Node</em>s are matched. The model graph contains 32 <em>Node</em>s, so 32 matches are to be expected.
</p>


<h3>testACMatchAllNodes</h3>
<ul>
<li>Graph used: manyNodes</li>
<li>Rule used: acMAtchAllNodes</li>
</ul>
<img src="img/testMatchAllNodes.png" />
<p>
In this test, all <em>Node</em>s are matched. This rule's LHS and positive application condition (PAC) are identical, so all <em>Node</em>s matched by the LHS will be matched by the PAC as well. The model graph contains 32 <em>Node</em>s, so 32 matches are to be expected.
</p>

<h3>testMatchNodesWithVals</h3>
<ul>
<li>Graph used: nodesAndVals</li>
<li>Rule used: matchNOdesAndVals</li>
</ul>
<img src="img/testMatchNodesWithVals.png" />
<p>
In this test, all <em>Node</em> with <em>Val</em>s are matched. Because the matched <em>Node</em> and <em>Val</em>s are connected by a unidirectional edge (hasVals), this tests matching elements based on their edges.
</p>

<h3>testEmptyRule</h3>
<ul>
<li>Graph used: nodesAndVals</li>
<li>Rule used: emptyRule</li>
</ul>
<p>
This tests what happens if the rule is completely empty. There should be exactly 1 match, but this match should be empty, i.e. contain no nodes from the graph.
</p>

<h3>testOnlyNAC</h3>
<ul>
<li>Graph used: nodesAndVals</li>
<li>Rule used: onlyNAC</li>
</ul>
<p>
This tests if rules containing only a NAC are matched correctly. There should be no match. 
</p>

<h3>testOnlyPAC</h3>
<ul>
<li>Graph used: nodesAndVals</li>
<li>Rule used: onlyPAC</li>
</ul>
<p>
This tests if rules containing only a PAC are matched correctly. There should be exactly 1 match, but this match should be empty, i.e. contain no nodes from the graph.
</p>

<h3>testNestedPacPac</h3>
<ul>
<li>Graph used: nestedACTests</li>
<li>Rule used: nestedAC_pac-pac</li>
</ul>
<img src="img/nestedACTests_pac-pac.png" />
<p>
This tests if nested application conditions work correctly. A PAC is nested inside a PAC. A positive application condition matching a <em>Node</em> with a hasVals edge to a <em>Val</em> (2) is nested inside a positive application condition matching a parent and child node (1). There is a mapping between the <em>Node</em> in (2) and the parent node in (1). There also is a mapping between the Rule's LHS <em>Node</em> and the child node in (1).<br />
So, this Rule should match a Node which has ([1] a parent Node which ([2] has an edge to a Val)). This is the case for t_11 and t_12.
</p>

<h3>testNestedPacNac</h3>
<img src="img/nestedACTests_pac-nac.png" />
<ul>
<li>Graph used: nestedACTests</li>
<li>Rule used: nestedAC_pac-nac</li>
</ul>
<p>
This tests if nested application conditions work correctly. A NAC is nested inside a PAC. A negative application condition matching a <em>Node</em> with a hasVals edge to a <em>Val</em> (2) is nested inside a positive application condition matching a parent and child node (1). There is a mapping between the <em>Node</em> in (2) and the parent node in (1). There also is a mapping between the Rule's LHS <em>Node</em> and the child node in (1).<br />
So, this Rule should match a Node which has ([1] a parent Node which ([2] doesn't have an edge to a Val)). This is the case for t_111 and t_1. It is not the case for unconnected (unconnected doesn't have a parent node).
</p>

<h3>testNestedNacPac</h3>
<img src="img/nestedACTests_nac-pac.png" />
<ul>
<li>Graph used: nestedACTests</li>
<li>Rule used: nestedAC_nac-pac</li>
</ul>
<p>
This tests if nested application conditions work correctly. A PAC is nested inside a NAC. A positive application condition matching a <em>Node</em> with a hasVals edge to a <em>Val</em> (2) is nested inside a negative application condition matching a parent and child node (1). There is a mapping between the <em>Node</em> in (2) and the parent node in (1). There also is a mapping between the Rule's LHS <em>Node</em> and the child node in (1).<br />
So, this Rule should match a Node which ([1] doesn't have a parent Node which ([2] has an edge to a Val)). This is the case for t111 (its parent node, t_11, doesn't have an edge to a Val), t_1 (its parent node, top, doesn't have an edge to a Val), top (top doesn't hava a parent node) and unconnected (unconnected doesn't have a parent node).
</p>

<h3>testNestedNacNac</h3>
<img src="img/nestedACTests_nac-nac.png" />
<ul>
<li>Graph used: nestedACTests</li>
<li>Rule used: nestedAC_nac-nac</li>
</ul>
<p>
This tests if nested application conditions work correctly. A NAC is nested inside a NAC. A negative application condition matching a <em>Node</em> with a hasVals edge to a <em>Val</em> (2) is nested inside a negative application condition matching a parent and child node (1). There is a mapping between the <em>Node</em> in (2) and the parent node in (1). There also is a mapping between the Rule's LHS <em>Node</em> and the child node in (1).<br />
So, this Rule should match a Node which ([1] doesn't have a parent Node which ([2] doesn't have an edge to a Val)). This is the case for t_11, t_12 (their parent node is t_1, which has an edge to a Val) and top and unconnected (top and unconnected do not have a parent node).
</p>

<h3>testAndNestedCondition</h3>
<ul>
<li>Graph used: nestedACTests</li>
<li>Rule used: andNestedCondition</li>
</ul>
<img src="img/nestedACTests_and.png" />
<p>
This tests if AND operators work correctly. Two positive application conditions are linked using an AND operator, one matching <em>Node</em>s with a parent node, the other matching <em>Node</em>s with a child node. There is a mapping between the Rule's LHS <em>Node</em> and the respective <em>Node</em> in both PACs.<br />
So, this Rule should match a Node which has a parent node and a child node. This is the case for t_1 and t_11.
</p>

<h3>testOrNestedCondition</h3>
<ul>
<li>Graph used: nestedACTests</li>
<li>Rule used: orNestedCondition</li>
</ul>
<img src="img/nestedACTests_or.png" />
<p>
This tests if OR operators work correctly. Two positive application conditions are linked using an OR operator, one matching <em>Node</em>s with a parent node, the other matching <em>Node</em>s with a child node. There is a mapping between the Rule's LHS <em>Node</em> and the respective <em>Node</em> in both PACs.<br />
So, this Rule should match a Node which has a parent node, a child node or both. This is the case for top, t_1, t_11, t_12 and t_111. It is not the case for unconnected.
</p> 

<h3>testNotNestedCondition</h3>
<ul>
<li>Graph used: nestedACTests</li>
<li>Rule used: notNestedCondition</li>
</ul>
<img src="img/nestedACTests_not.png" />
<p>
This tests if NOT operators work correctly. A positive application condition matching a <em>Node</em> with a parent node is negated using a NOT operator. There is a mapping between the Rule's LHS <em>Node</em> and the PAC's <em>Node</em>.<br />
So, this Rule should match a Node which does not have a parent node. This is the case for top and unconnected.
</p>

<!-- ***************************************************************** -->

<h1>Creating Nodes</h1>
<p>4 tests</p>
<p>These tests test several aspects of Node creation. All tests are implemented in <span class="classname">CreateNodes.java</span>, all graphs used can be found in <span class="graph">createNodesModels</span>. The associated henshin rule file is <span class="henshin">basicTests.henshin</span></p>

<h3>testCreateNodeWithContainmentEdge</h3>
<img src="img/graphWithCont.png" />
<img src="img/graphWithOneNode.png" />
<ul>
<li>Graph used: graphWithCont</li>
<li>Rule used: createNodeWithContainmentEdge</li>
</ul>
<p>
In this test, a new <em>Node</em> with a containment edge should be created. The initial graph <span class="graph">graphWithCont</span> contains just the containment. Adding a <em>Node</em> with a containment edge should result in <span class="graph">graphWithOneNode</span></p>

<h3>testCreateNodeWithContainmentEdgeAndUnidirectionalEdgeToNode</h3>
<ul>
<li>Graph used: graphWithOneNode</li>
<li>Rule used: createNodeWithUnidirectionalEdge</li>
</ul>
<img src="img/graphWithOneNode.png" />
<img src="img/graphAfter_createNodeWithUnidirectionalEdge.png" />
<p>
In this test, a new node (type <em>Val</em>) with a unidirectional edge to a <em>Node</em> should be created.
</p>

<h3>testCreateNodeWithContainmentEdgeAndBidirectionalEdge3</h3>
<ul>
<li>Graph used: graphWithOneNode</li>
<li>Rule used: createNodeWithBidirectionalEdge3</li>
</ul>
<img src="img/graphWithOneNode.png" />
<img src="img/graphAfter_createNodeWithBidirectionalEdge.png" />
<p>
In this test, a new <em>Node</em> with a bidirectional edge to an existing <em>Node</em> should be created. The rule used in this test specifies both directions of the bidirectional edge.
</p>

<h3>testCreateRootNode</h3>
<ul>
<li>Rule used: createRootNode</li>
</ul>
<p>
In this test, a root node should be created in an empty graph.
</p>


<!-- *********************************************************************** -->
<h1>Deleting Nodes</h1>
<p>4 tests</p>
<p>These tests test several aspects of deleting Nodes. All tests are implemented in <span class="classname">DeleteNodes.java</span>, all graphs used can be found in <span class="graph">deleteNodesModels</span>. The associated henshin rule file is <span class="henshin">basicTests.henshin</span></p>

<h3>testDeleteNodeWithContainmentEdge</h3>
<ul>
<li>Graph used: graphWithOneNode</li>
<li>Rule used: deleteNodeWithContainmentEdge</li>
</ul>
<img src="img/graphWithOneNode.png" />
<img src="img/graphWithCont.png" />
<p>In this test, a <em>Node</em> with a containment edge should be deleted. 
</p>

<h3>testDeleteNodeWithUnidirectionalEdge1</h3>
<ul>
<li>Graph used: graphBefore_deleteNodeWithUnidirectionalEdge</li>
<li>Rule used: deleteNodeWithUnidirectionalEdge1</li>
</ul>
<img src="img/graphBefore_deleteNodeWithUnidirectionalEdge.png" />
<img src="img/graphAfter_deleteNodeWithUnidirectionalEdge1.png" />
<p>
In this test, a node (of type <em>Val</em>) with an incoming unidirectional edge (hasVals) from a <em>Node</em> should be deleted (i.e. the containment edge and the incoming edge are removed, and the node is removed from the graph as well).
</p>

<h3>testDeleteNodeWithUnidirectionalEdge2</h3>
<ul>
<li>Graph used: graphBefore_deleteNodeWithUnidirectionalEdge</li>
<li>Rule used: deleteNodeWithUnidirectionalEdge2</li>
</ul>
<img src="img/graphBefore_deleteNodeWithUnidirectionalEdge.png" />
<img src="img/graphAfter_deleteNodeWithUnidirectionalEdge2.png" />
<p>
In this test, a <em>Node</em> with an outgoing unidirectional edge (hasVals) should be deleted (i.e. the containment edge and the outgoing edge are removed, and the <em>Node</em> is removed from the graph as well).
</p>

<h3>testDeleteNodeWithBidirectionalEdge3</h3>
<ul>
<li>Graph used: graphBefore_deleteNodeWithBidirectionalEdge</li>
<li>Rule used: deleteNodeWithBidirectionalEdge3</li>
</ul>
<img src="img/graphBefore_deleteNodeWithBidirectionalEdge_.png" />
<img src="img/graphAfter_deleteNodeWithBidirectionalEdge.png" />
<p>
The graph used for this test contains a containment and two <em>Nodes</em> with a bidirectional edge between them. One of these <em>Node</em>s should be deleted, i.e. its containment edge and the bidirectional edge to the other <em>Node</em> should be removed and it should also be removed from the graph.
</p>
<p>In this test, both components of the bidirectional edge are specified, and <strong>n2</strong> should be deleted.
</p>



<!-- *********************************************************************** -->


<h1>Creating and removing edges</h1>
<p>4 tests</p>
<p>These tests test several aspects of creating and removing edges between nodes in the model graph. Tests on containment edges have already been implemented implicitly in the creating/deleting nodes tests. All tests are implemented in <span class="classname">CreateDeleteEdges.java</span>, all graphs used can be found in <span class="graph">createDeleteEdgesModels</span>. The associated henshin rule file is <span class="henshin">basicTests.henshin</span></p>

<h2>Creating edges</h2>
<h3>testCreateUnidirectionalEdge</h3>
<ul>
<li>Graph used: graphBefore_edgesCreateUnidirectionalEdge</li>
<li>Rule used: edgesCreateUnidirectionalEdge</li>
</ul>
<img src="img/graphBefore_edgesCreateUnidirectionalEdge.png" />
<img src="img/graphAfter_edgesCreateUnidirectionalEdge.png" />
<p>In this test, a unidirectional edge (hasVals) between a <em>Node</em> and a <em>Val</em> should be created.
</p>


<h3>testCreateBidirectionalEdge3</h3>
<ul>
<li>Graph used: graphBefore_edgesCreateBidirectionalEdge</li>
<li>Rule used: edgesCreateBidirectionalEdge3</li>
</ul>
<img src="img/graphBefore_edgesCreateBidirectionalEdge_.png" />
<img src="img/graphAfter_edgesCreateBidirectionalEdge.png" />
<p>
In this test, a bidirectional edge between two <em>Node</em>s should be created. This is accomplished by specifying both component edges of the bidirectional edge (parentNode and childNodes).
</p>

<h2>Removing edges</h2>
<h3>testRemoveUnidirectionalEdge</h3>
<ul>
<li>Graph used: graphAfter_edgesCreateUnidirectionalEdge</li>
<li>Rule used: edgesRemoveUnidirectionalEdge</li>
</ul>
<img src="img/graphAfter_edgesCreateUnidirectionalEdge.png" />
<img src="img/graphBefore_edgesCreateUnidirectionalEdge.png" />
<p>
In this test, a unidirectional edge from a <em>Node</em> to a <em>Val</em> should be removed from the model graph.
</p>



<h3>testRemoveBidirectionalEdge3</h3>
<ul>
<li>Graph used: graphAfter_edgesCreateBidirectionalEdge</li>
<li>Rule used: edgesRemoveBidirectionalEdge1</li>
</ul>
<img src="img/graphAfter_edgesCreateBidirectionalEdge.png" />
<img src="img/graphBefore_edgesCreateBidirectionalEdge_.png" />
<p>
In this test, a bidirectional edge should be removed. Both components of the bidirectional edge (parentNode, childNodes) are specified, so the edge should be removed.
</p>

<!-- ----------------------------- -->


<h1>Parameter tests</h1>
<p>9 tests</p>
<p>These tests test various aspects of parameter handling. All Rules used for these tests are contained in parameterTests.henshin</p>

<h3>testParameterName</h3>
<ul>
<li>Graph used: paramTest</li>
<li>Rule used: parameterName</li>
</ul>
<img src="img/paramTest.png" />
<img src="img/paramTest_testParameterName.png" />
<p>
In this test, a String is passed as a parameter. The parameter is then used to match the nodename of a <em>Node</em> by using the parameter as an attribute in the Rule's LHS. If successful, nd1 will be deleted.
</p>

<h3>testParameterObject</h3>
<ul>
<li>Graph used: paramTest</li>
<li>Rule used: parameterObject</li>
</ul>
<img src="img/paramTest.png" />
<img src="img/paramTest_testParameterName.png" />
<p>
In this test, an Object is passed as a parameter. The parameter is then used to match a <em>Node</em> by using the parameter as a Node in the Rule's LHS. If successful, nd1 will be deleted.
</p>

<h3>testParameterInOut1</h3>
<ul>
<li>Graph used: paramTest</li>
<li>Rule used: parameterInOut</li>
</ul>
<p>
This tests correct parameter passing. First, an attribute name is set as a parameter. The Rule will match a <em>Node</em>, using the parameter to match the nodename. The matched node will then be assigned to another parameter.<br />
If parameter handling is successful, the Rule's comatch should contain a parameter mapping between the parameter and the <em>Node</em> object.
</p>

<h3>testParameterInOut2</h3>
<ul>
<li>Graph used: paramTest</li>
<li>Rule used: parameterInOut</li>
</ul>
<p>
This tests correct parameter passing. First, a <em>Node</em> is set as a parameter. The Rule will match a <em>Node</em>, using the parameter to match the nodename. The matched node's nodename will then be assigned to another parameter.<br />
If parameter handling is successful, the Rule's comatch should contain a parameter mapping between the parameter and the nodename.
</p>

<h3>testParameterTu</h3>
<ul>
<li>Graph used: paramTest</li>
<li>TransformationUnit used: parameterUnit</li>
</ul>
<p>
This tests if parameters are correctly handled in transformation units. The transformation unit used in this tests is a sequential unit which applies the Rules parameterInOut and parameterObject sequentially. A <em>Node</em>'s nodename is passed via the parameter tu_param_in, which is then mapped to parameterInOut's param_ndname. parameterInOut's param_node is mapped to the parameter p2, and p2 is mapped to parameterObject's parameter param_nd. Effectively, the matched <em>Node</em> is passed to parameterObject and then deleted.
</p>

<h3>testParameterComposition1</h3>
<ul>
<li>Graph used: paramTest</li>
<li>Rule used: parameterComposition1</li>
</ul>
<p>
This tests composition of parameters by the engine. In this test, there are three parameters: p1, p2 and vl. vl is a <em>Val</em> on the LHS. The Rule sets the intvl (type: EInt) of vl to p1 + p2.<br />
p1 is set to 20, p2 is set to 30. If the engine handles integer parameters correctly, the intvl of the value should equal 50.
</p>

<h3>testParameterComposition2</h3>
<ul>
<li>Graph used: paramTest</li>
<li>Rule used: parameterComposition2</li>
</ul>
<p>
This tests composition of parameters by the engine. In this test, there are three parameters: p1, p2 and vl. vl is a <em>Val</em> on the LHS. The Rule sets the valname (type: EString) of vl to p1 + p2.<br />
p1 is set to 20, p2 is set to 30. If the engine handles parameters correctly, the valname of vl should equal "50" after execution.
</p>

<h3>testParameterComposition3</h3>
<ul>
<li>Graph used: paramTest</li>
<li>Rule used: parameterComposition2</li>
</ul>
<p>
This tests composition of parameters by the engine. In this test, therer are three parameters: p1, p2 and vl. vl is a <em>Val</em> on the LHS. The Rule sets the valname (type: EString) of vl to p1 + p2.<br />
p1 is set to "20", p2 is set to "30". If the engine handles parameters correctly, the valname of vl should equal "2030" after execution.
</p>

<h3>testAttributeCondition1</h3>
<ul>
<li>Graph used: paramTest</li>
<li>Rule used: attribCond1</li>
</ul>
<img src="img/paramTest.png" />
<img src="img/graphAfter_attribCond_.png" />
<p>In this test, attribute conditions are tested. The attribute condition is set so that a <em>Val</em> with intvl > 20 will be deleted. This is the case for vl2 (intvl = 108).
</p>

<h1>Transformation Unit tests</h1>
<p>13 tests</p>
<p>These tests test various aspects of Transformation Units. The Rules and TransformationUnits for these tests are contained in transformationUnitTests.henshin</p>

<h3>amalgamationUnitTest</h3>
<img src="img/graphBefore_amalgamationUnit.png" />
<img src="img/graphAfter_amalgamationUnit.png" />
<p>
This tests the amalgamation unit. The amalgamation unit's kernel rule finds a <em>Node</em> with a specified nodename. The multi rules delete the <em>Node</em>'s child nodes and <em>Val</em>s.<br />
Executing the amalgamation unit with nodename = "R" should therefore delete the Nodes RL and RR as well as the values vr1, vr2 and vr3.
</p>

<h3>priorityUnitTest</h3>
<p>
This tests correct execution of the priority unit. A priority unit will execute the topmost subunit that can be executed.<br />
The priority unit used for this test will apply deleteNodeWithVal or deleteVal. deleteNodeWithVal deletes a <em>Node</em> (which has no child <em>Node</em>s, but a parent <em>Node</em>) with a hasVals edge to a <em>Val</em>. deleteVal deletes a <em>Val</em>.<br />
When executing the priority unit the first time, LL and vl2 are matched by deleteNodeWithVal, so they are deleted.
<img src="img/graphBefore_priorityUnit_.png" />
<br />
When executing the priority unit the second time, L and vl1 are matched by deleteNodeWithVal, so they are deleted.
<img src="img/graphAfter_priorityUnit_1.png" />
<br />
When executing the priority unit the third time, no remaining suitable <em>Node</em>-<em>Val</em> pairs for deleteNodeWithVal can be found, so a match for deleteVal is created. vl3 is matched by deleteVal, so it is deleted.
<img src="img/graphAfter_priorityUnit_2.png" />
<img src="img/graphAfter_priorityUnit_3.png" />
</p>

<h3>conditionalUnitTest</h3>
<img src="img/graphWithCont.png" />
<img src="img/graphAfter_conditionalUnit1.png" />
<img src="img/graphAfter_conditionalUnit2.png" />
<p>This tests the conditional unit. The condition Rule is findVal, which will be true if the value having the specified valname can be found. If the condition is true, the (existing) value vl1 will be changed to intvl=20. If the condition is false, the value vl1 will be created and will be set to intvl=15.<br />
The conditional unit is executed two times on a graph containing just the containment. In the first run, the value will be created (testing the conditional unit's ELSE part). In the second run, the value will be modified (testing the conditional unit's IF and THEN part).
</p>

<h3>independentUnitTest</h3>
<img src="img/graphWithCont.png" />
<br>
(1)
<img src="img/graphAfter_independentUnit1a.png" />
<img src="img/graphAfter_independentUnit2a.png" />
<br>
(2)
<img src="img/graphAfter_independentUnit1b.png" />
<img src="img/graphAfter_independentUnit2b.png" />
<p>This tests the independent unit. Independent units randomly apply or execute their Rules/TransformationUnits. There are two Rules in the independent unit, one to create a <em>Node</em> node1 if it doesn't already exist, and one to create a <em>Node</em> node2 if it doesn't already exist.<br />
The independent unit is executed until both <em>Node</em>s have been created, but at most 100 times.
</p>

<h2>CountedUnit tests</h2>
<h3>countedUnitTest1</h3>
<img src="img/graphBefore_countedUnit.png" />
<img src="img/graphAfter_countedUnit.png" />
<p>
This tests executing the counted unit until no match can be found (count = -1). The Rule used for the counted unit deletes a child node at the bottom level, i.e. a <em>Node</em> with a parent node, but no child nodes. When running this until no match can be found, only the topmost node (nodename = 0) should remain.
</p>

<h3>countedUnitTest2</h3>
<img src="img/graphBefore_countedUnit.png" />
<img src="img/graphAfter_countedUnit.png" />
<p>
This tests executing the counted unit a fixed number of times (count = 8). As there are 8 child nodes, the counted unit should execute successfully and only the topmost node (nodename = 0) should remain.
</p>

<h3>countedUnitTest3</h3>
<p>
This tests executing the counted more often than matches can be found (count = 10). As there are 9 nodes in the graph, deleting 10 nodes will inevitably fail. Therefore, asserting the graph has been transformed into the graph containing just the topmost node (nodename = 0) should fail, which is the expected result of this test. (Note: This test will be successful if an AssertionError is thrown) 
</p>

<h3>countedUnitTest3ReturnValue</h3>
<p>
This test tests the return value of an unsuccessful execution of countedUnit. As in countedUnitTest3, the counted unit is executed 10 times, which will fail. It should therefore return false.
</p>

<h3>countedUnitTest3Undo</h3>
<p>
This tests un-doing graph transformations. As in countedUnitTest3, the counted unit is executed 10 times, which will fail. Changes to the graph made by the execution of the CountedUnit will then be automatically undone, resulting in the exact graph as it was before executing the countedUnit.
</p>

<h3>countedUnitTest4</h3>
<p>
This tests executing counted units with negative counts (count = -2). It should therefore especially fail to transform the graph into what running the counted unit indefinitely (as with count = -1). (Note: This test will be successful if an AssertionError is thrown)
</p>

<h2>sequential unit tests</h2>
<h3>sequentialUnitTest</h3>
<img src="img/graphBefore_sequentialUnit.png" />
<img src="img/graphAfter_sequentialUnit.png" />
<p>
This tests the sequential unit. A sequential unit executs its subunits sequentially. The sequential unit used for this test will execute deleteVal, deleteNodeWithVal, deleteVal. (The second deleteVal is encapsulated in another transformation unit, as multiple identical rules are not supported in transformation units.)<br />
deleteVal will delete vl1. deleteNodeWithVal will delete LL, vl2. deleteVal will delete vl3.
</p>

<h3>sequentialUnitTestUndo</h3>
<p>
This tests undo operations after a sequential unit has been executed and failed. In this case, changes to the graph made by the sequential unit will be un-done. This test will execute a sequential unit which will inevitably fail and then check if the graph after execution is equal to the graph before execution.
</p>

<h3>sequentialUnitTestUndo2</h3>
<p>
This tests undo operations after a sequential unit has been executed and failed. If the Rule applications are not un-done correctly, the behavior of transformation units executed after the failed execution can be different from the behavior on the initial graph, although it should be the same.<br />
This test constructs a suitable scenario to assert that not only the graph's contents remain unchanged after the undo operation, but also that the graph's structure remains unchanged. The constructed sequential unit's behavior is highly dependent on match order (the first deleteVal has 3 matches; which <em>Val</em> will be used (and thus deleted) is dependent on the order of edges from the containment node), so changing the graph's structure will very likely lead to unexpected results.
</p>


<h1>Engine options tests</h1>
<p>2 tests</p>
<p>These tests concern various configurable matching options.</p>

<h3>testNonInjective1</h3>
<img src="img/nonInjective1_1.png" />
<p>In this test, the non-injective matching mode is tested. The rule will produce a match containing a <em>Node</em> and its two child Nodes. First, with standard injective matching, this rule will produce no match, as there are no Nodes with two child nodes.<br />
When injective matching is activated, finding matches for the rule will result in one match containing the Node once and its child Node twice.<br />
<img src="img/nonInjective1_2.png" />
</p>

<h3>testNonInjective2</h3>
<img src="img/nonInjective2.png" />
<p>
In this test, the non-injective matching mode is tested. First, with standard injective matching, the rule will produce 2 matches: (n1, (n2, n3)) and (n1, (n3, n2)).<br />
When non-injective matching is turned on, the rule will produce 4 matches: (n1, (n2, n2)), (n1, (n2, n3)), (n1, (n3, n2)), (n1, (n3, n3)).
</p>

</body>
</html>






















