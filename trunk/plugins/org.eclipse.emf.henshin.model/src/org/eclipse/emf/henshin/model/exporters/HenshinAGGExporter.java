package org.eclipse.emf.henshin.model.exporters;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.henshin.HenshinModelExporter;
import org.eclipse.emf.henshin.HenshinModelPlugin;
import org.eclipse.emf.henshin.model.Attribute;
import org.eclipse.emf.henshin.model.Edge;
import org.eclipse.emf.henshin.model.Graph;
import org.eclipse.emf.henshin.model.Node;
import org.eclipse.emf.henshin.model.Rule;
import org.eclipse.emf.henshin.model.TransformationSystem;
import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

/**
 * Henshin model exporter for AGG.
 * @author Christian Krause
 */
public class HenshinAGGExporter implements HenshinModelExporter {

	/**
	 * ID of this model exporter.
	 */
	public static final String EXPORTER_ID = "org.eclipse.emf.henshin.henshin2agg";
	
	// Colors for node types:
	private static int[][] COLORS = { 
		{   0,   0,   0 },  // black
		{ 255,   0,   0 },  // red
		{   0,   0, 255 },  // blue
		{ 128,   0, 128 },  // purple
		{ 128, 128,   0 },  // yellow
		{ 128, 128, 128 }	// grey
	};
	
	// XML document:
	private Document document;
	
	// Element ID:
	private int elementID = 0;
	
	// Color index:
	private int color = 0;
	
	// Node type IDs:
	private Map<EClass,String> nodeTypeIDs, nodeIDs;

	// Edge type IDs:
	private Map<EReference,String> edgeTypeIDs;

	// Attribute type IDs:
	private Map<EAttribute,String> attrTypeIDs;

	// Graph node IDs:
	private Map<Node,String> graphNodeIDs;
	
	// Graph edge IDs:
	private Map<Edge,String> graphEdgeIDs;
	
	// Translated attributes:
	private Set<EAttribute> translatedAttributes;
	
	// Warnings:
	private List<String> warnings;
	
	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.HenshinModelExporter#doExport(org.eclipse.emf.henshin.model.TransformationSystem, org.eclipse.emf.common.util.URI)
	 */
	@Override
	public IStatus doExport(TransformationSystem system, URI uri) {

		// Reset first:
		reset();
		try {
			
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			DocumentBuilder builder = factory.newDocumentBuilder();
			document = builder.newDocument();
			
			// Root element:
			Element root = newElement("Document", document);

			// Signature:
			Comment comment = document.createComment("Generated by Henshin on " + new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(new Date()));
			root.appendChild(comment);

			// Graph transformation system:
			Element systemElem = newElement("GraphTransformationSystem", root);
			String name = system.getName();
			if (name==null || name.trim().length()==0) {
				if (system.eResource()!=null) {
					name = system.eResource().getURI().trimFileExtension().lastSegment();
				} else {
					name = "GraGra";
				}
			}
			systemElem.setAttribute("name", name);
			Element javaTag = newTaggedValue("AttrHandler", "Java Expr", systemElem);
			newTaggedValue("Package", "java.lang", javaTag);
			newTaggedValue("Package", "java.util", javaTag);
			newTaggedValue("Package", "com.objectspace.jgl", javaTag);
			newTaggedValue("CSP", "true", systemElem);
			newTaggedValue("injective", "true", systemElem);
			newTaggedValue("dangling", "true", systemElem);
			newTaggedValue("NACs", "true", systemElem);
			newTaggedValue("PACs", "true", systemElem);
			newTaggedValue("TypeGraphLevel", "ENABLED_MAX", systemElem);
			
			// Types:
			Element typesElem = newElement("Types", systemElem);
			
			// Type graph:
			Element typeGraphElem = newElement("Graph", typesElem);
			typeGraphElem.setAttribute("kind", "TG");
			typeGraphElem.setAttribute("name", "TypeGraph");
			typesElem.removeChild(typeGraphElem);
			
			// Nodes and attribute types:
			for (EPackage epackage : system.getImports()) {
				for (EClassifier eclassifier : epackage.getEClassifiers()) {
					if (eclassifier instanceof EClass) {
						EClass eclass = (EClass) eclassifier;
						
						// Node type:
						Element nodeTypeElem = newElement("NodeType", typesElem);
						nodeTypeElem.setAttribute("abstract", String.valueOf(eclass.isAbstract()));
						nodeTypeElem.setAttribute("name", eclass.getName() + "%:RECT:" + newColor() + ":[NODE]:");
						nodeTypeIDs.put(eclass, nodeTypeElem.getAttribute("ID"));
						
						// Node in type graph:
						Element nodeElem = newElement("Node", typeGraphElem);
						nodeElem.setAttribute("type", nodeTypeIDs.get(eclass));
						nodeIDs.put(eclass, nodeElem.getAttribute("ID"));
						
						// Attributes:
						for (EAttribute attribute : eclass.getEAttributes()) {
							EDataType t = attribute.getEAttributeType();
							EcorePackage p = EcorePackage.eINSTANCE;
							if (t==p.getEInt() || t==p.getEBoolean() || t==p.getEString()) {
								Element attrElem = newElement("AttrType", nodeTypeElem);
								attrElem.setAttribute("attrname", attribute.getName());
								attrElem.setAttribute("typename", t.getInstanceClassName());
								attrElem.setAttribute("visible", "true");
								attrTypeIDs.put(attribute, attrElem.getAttribute("ID"));
							} else {
								warnings.add(" - Attribute " + eclass.getName() + "." + attribute.getName() + 
										" of type " + t.getName() + " not supported");
							}
						}
					}
				}
			}

			// Edge types:
			for (EPackage epackage : system.getImports()) {
				for (EClassifier eclassifier : epackage.getEClassifiers()) {
					if (eclassifier instanceof EClass) {
						EClass eclass = (EClass) eclassifier;
						
						// Edges:
						for (EReference reference : eclass.getEReferences()) {
							
							// Edge type:
							Element edgeTypeElem = newElement("EdgeType", typesElem);
							edgeTypeElem.setAttribute("abstract", "false");
							edgeTypeElem.setAttribute("name", getReferenceName(reference) + "%:SOLID_LINE:java.awt.Color[r=0,g=0,b=0]:[EDGE]:");
							edgeTypeIDs.put(reference, edgeTypeElem.getAttribute("ID"));
							
							// Edge in type graph:
							Element edgeElem = newElement("Edge", typeGraphElem);
							edgeElem.setAttribute("type", edgeTypeIDs.get(reference));
							edgeElem.setAttribute("source", nodeIDs.get(eclass));
							edgeElem.setAttribute("target", nodeIDs.get(reference.getEReferenceType()));
							edgeElem.setAttribute("sourcemin", "0");
							edgeElem.setAttribute("targetmin", reference.getLowerBound()+"");
							if (reference.getUpperBound()>=0) {
								edgeElem.setAttribute("targetmax", reference.getUpperBound()+"");
							}
						}
					}
				}
			}

			// Now append the type graph:
			typesElem.appendChild(typeGraphElem);
			
			// Rules:
			for (Rule rule : system.getRules()) {
				Element ruleElem = newElement("Rule", systemElem);
				ruleElem.setAttribute("name", rule.getName());
				
				// LHS and RHS:
				convertGraph(rule.getLhs(), ruleElem, "LHS", "Left");
				convertGraph(rule.getLhs(), ruleElem, "RHS", "Right");	
			}
			
			// Save the XML file:
			TransformerFactory transFactory = TransformerFactory.newInstance();
			Transformer trans = transFactory.newTransformer();
			trans.setOutputProperty(OutputKeys.INDENT, "yes");
			File file = new File(uri.toFileString());
			StreamResult result = new StreamResult(file);
			DOMSource source = new DOMSource(document);
			trans.transform(source, result);

			// Clean up:
			reset();
			
		}
		catch (Throwable t) {
			return new Status(IStatus.ERROR, HenshinModelPlugin.PLUGIN_ID, "Error exporting to AGG", t);
		}
		if (!warnings.isEmpty()) {
			String message = "Warning:\n";
			for (String warning : warnings) {
				message = message + "\n" + warning;
			}
			return new Status(IStatus.WARNING, HenshinModelPlugin.PLUGIN_ID, message);
		}
		return Status.OK_STATUS;
	}

	/*
	 * Translate a graph into XML.
	 */
	private void convertGraph(Graph graph, Element parent, String kind, String name) {
		Element graphElem = newElement("Graph", parent);
		graphElem.setAttribute("kind", kind);
		graphElem.setAttribute("name", name);
		
		// Nodes:
		for (Node node : graph.getNodes()) {
			Element nodeElem = newElement("Node", graphElem);
			nodeElem.setAttribute("type", nodeTypeIDs.get(node.getType()));
			graphNodeIDs.put(node, nodeElem.getAttribute("ID"));
			
			// Attributes:
			for (Attribute attribute : node.getAttributes()) {
				if (translatedAttributes.contains(attribute.getType())) {
					EDataType t = attribute.getType().getEAttributeType();
					EcorePackage p = EcorePackage.eINSTANCE;
					Element attrElem = newElement("Attribute", nodeElem);
					attrElem.setAttribute("constant", "true");
					attrElem.setAttribute("type", attrTypeIDs.get(attribute.getType()));
					Element valueElem = newElement("Value", attrElem);
					if (t==p.getEInt()) {
						// TODO
					}
				}
			}
		}
		
	}
	
	/*
	 * Get the name of a reference.
	 */
	private String getReferenceName(EReference reference) {
		String srcName = ((EClass) reference.eContainer()).getName();
		srcName = Character.toLowerCase(srcName.charAt(0)) + srcName.substring(1);
		String refName = reference.getName();
		refName = Character.toUpperCase(refName.charAt(0)) + refName.substring(1);
		return srcName + refName;
	}
	
	/*
	 * Create a new document element.
	 */
	private Element newElement(String type, org.w3c.dom.Node parent) {
		Element elem = document.createElement(type);
		elem.setAttribute("ID", "I" + (elementID++));
		elem.setIdAttribute("ID", true);
		parent.appendChild(elem);
		return elem;
	}
	
	/*
	 * Create a new color (string representation for AGG).
	 */
	private String newColor() {
		int[] rgb = COLORS[color];
		color = (color+1) % COLORS.length;
		return "java.awt.Color[r=" + rgb[0] + ",g=" + rgb[1] + ",b=" + rgb[2] + "]";
	}

	/*
	 * Create a new tagged value.
	 */
	private Element newTaggedValue(String tag, String tagValue, org.w3c.dom.Node parent) {
		Element elem = document.createElement("TaggedValue");
		elem.setAttribute("Tag", tag);
		elem.setAttribute("TagValue", tagValue);		
		parent.appendChild(elem);
		return elem;
	}

	/*
	 * Reset internal data.
	 */
	private void reset() {
		nodeTypeIDs = new HashMap<EClass, String>();
		nodeIDs = new HashMap<EClass, String>();
		edgeTypeIDs = new HashMap<EReference, String>();
		attrTypeIDs = new HashMap<EAttribute, String>();
		graphNodeIDs = new HashMap<Node, String>();
		graphEdgeIDs = new HashMap<Edge, String>();
		translatedAttributes = new HashSet<EAttribute>();
		warnings = new ArrayList<String>();
		elementID = 0;
		color = 0;
	}
	
	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.HenshinModelExporter#getExporterName()
	 */
	@Override
	public String getExporterName() {
		return "AGG";
	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.HenshinModelExporter#getExportFileExtensions()
	 */
	@Override
	public String[] getExportFileExtensions() {
		return new String[] { "ggx" };
	}

}
