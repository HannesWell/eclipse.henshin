package org.eclipse.emf.henshin.statespace.external.prism;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.henshin.model.Rule;
import org.eclipse.emf.henshin.statespace.State;
import org.eclipse.emf.henshin.statespace.StateSpace;
import org.eclipse.emf.henshin.statespace.StateSpaceExporter;
import org.eclipse.emf.henshin.statespace.StateSpaceIndex;
import org.eclipse.emf.henshin.statespace.StateSpacePlugin;
import org.eclipse.emf.henshin.statespace.Transition;

/**
 * Exporter for PRISM. This generates a MDP model.
 * @author Christian Krause
 */
public class MDPStateSpaceExporter implements StateSpaceExporter {

	// The state space index:
	private StateSpaceIndex index;

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.statespace.export.StateSpaceExporter#export(org.eclipse.emf.henshin.statespace.StateSpace, org.eclipse.emf.common.util.URI, org.eclipse.core.runtime.IProgressMonitor)
	 */
	@Override
	public void export(StateSpace stateSpace, URI uri, String parameters, IProgressMonitor monitor) throws IOException {

		int stateCount = stateSpace.getStates().size();
		monitor.beginTask("Exporting state space...", 2*stateCount);
		
		// Shall we produce an explicit model?
		boolean explicit = "tra".equalsIgnoreCase(uri.fileExtension());
		
		// Determine probabilistic rules:
		Map<String,List<Rule>> probRules = new LinkedHashMap<String,List<Rule>>();
		for (Rule rule : stateSpace.getRules()) {
			List<Rule> rules = probRules.get(rule.getName());
			if (rules==null) {
				rules = new ArrayList<Rule>();
				probRules.put(rule.getName(), rules);
			}
			rules.add(rule);
		}

		// Export to file...
		File file = new File(uri.toFileString());
		OutputStream out = new BufferedOutputStream(new FileOutputStream(file), 65536);
		OutputStreamWriter writer = new OutputStreamWriter(out);

		// Output the header:
		if (!explicit) {
			writer.write("// MDP model generated by Henshin on " + new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(new Date()) + "\n\n");
			writer.write("mdp\n\n");
		}
		
		// Probability constants:
		Map<Rule, Double> probs = getProbabilities(stateSpace, probRules);
		if (!explicit) {
			for (String ruleName : probRules.keySet()) {
				List<Rule> rules = probRules.get(ruleName);
				if (rules.size()>1) {
					for (int i=0; i<rules.size(); i++) {
						writer.write("const double prob" + ruleName + (i+1));
						Double prob = probs.get(rules.get(i));
						if (prob!=null) {
							writer.write(" = " + prob);
						}
						writer.write(";\n");
					}
				}
			}
		}
		
		// Generate module specification:
		if (!explicit) {
			writer.write("\nmodule Transformation\n\n");
		}
		
		// State and transition count:
		if (explicit) {
			// Count number of probabilistic transitions:
			int probTrans = 0;
			for (State s : stateSpace.getStates()) {
				probTrans += MDPLabel.getTransitionsByLabel(s).keySet().size();
			}
			writer.write(stateSpace.getStates().size() + " " + probTrans + "\n");
		} else {
			writer.write("\ts : [0.." + stateSpace.getStates().size() + "];\n\n");
		}

		// Output the transitions:
		int removedIllegal = 0;
		for (State s : stateSpace.getStates()) {
			
			// Sort transitions by labels:
			Map<MDPLabel, List<Transition>> trs = MDPLabel.getTransitionsByLabel(s);
			for (MDPLabel l : trs.keySet()) {
				List<Transition> ts = trs.get(l);
				if (ts.isEmpty()) continue;
				
				// Check if all rules are enabled:
				String name = l.getTransition().getRule().getName();
				List<Rule> rules = probRules.get(name);
				boolean allEnabled = true;
				for (Rule r : rules) {
					boolean enabled = false;
					for (Transition t : ts) {
						if (t.getRule()==r) {
							enabled = true;
							break;
						}
					}
					if (!enabled) {
						allEnabled = false;
						break;
					}
				}
				if (!allEnabled) {
					removedIllegal++;
					continue;
				}
				
				// Output the transition:
				if (explicit) {
					writer.write(s.getIndex() + " ");
				} else {
					writer.write("\t[" + name + "] s=" + s.getIndex() + " -> ");
				}

				boolean first = true;
				for (Transition t : ts) {
					int index = rules.indexOf(t.getRule()) + 1;
					if (!first) {
						writer.write(explicit ? " " : " + ");
					}
					if (explicit) {
						writer.write(probs.get(t.getRule()) + ":" + t.getTarget().getIndex());
					} else {					
						if (rules.size()>1) {
							writer.write("prob" + name + index + ":(s'=" + t.getTarget().getIndex() + ")");
						} else {
							writer.write("(s'=" + t.getTarget().getIndex() + ")");						
						}
					}
					first = false;
				}
				
				if (explicit) {
					writer.write(" " + name + "\n");
				} else {				
					writer.write(";\n");
				}
			}
			
			// Update the monitor:
			monitor.worked(1);
			if (monitor.isCanceled()) {
				break;
			}

		}
		if (!explicit) {
			writer.write("\nendmodule\n\n");
		}
		
		// Did we remove any illegal transitions?
		if (removedIllegal>0) {
			StateSpacePlugin.INSTANCE.logWarning("Removed " + removedIllegal + " illegal probabilistic transitions");
		}

		// Initial states
		if (!explicit) {
			writer.write("init\n\t");
			for (int i=0; i<stateSpace.getInitialStates().size(); i++) {
				writer.write("s=" + stateSpace.getInitialStates().get(i).getIndex());
				if (i<stateSpace.getInitialStates().size()-1) writer.write(" | ");
			}
			writer.write("\nendinit\n");
		}

		// State labels:		
		if (parameters!=null && !explicit) {
			try {
				String expanded = PRISMUtil.expandLabels(parameters, index, 
						new SubProgressMonitor(monitor, stateCount));
				writer.write("\n" + expanded + "\n");
			} catch (Exception e) {
				throw new IOException(e);
			}
		}
		
		if (explicit) {
			File statesFile = new File(uri.toFileString().replaceAll(".tra", ".sta"));
			OutputStream statesOut = new BufferedOutputStream(new FileOutputStream(statesFile), 65536);
			OutputStreamWriter statesWriter = new OutputStreamWriter(statesOut);
			statesWriter.write("(s)\n");					
			for (int i=0; i<stateCount; i++) {
				statesWriter.write(i + ":(" + i + ")\n");					
			}
			statesWriter.close();
		}

		// Finished:
		writer.close();
		if (!monitor.isCanceled()) {
			monitor.done();
		}

	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.statespace.export.StateSpaceExporter#getName()
	 */
	@Override
	public String getName() {
		return "PRISM MDP";
	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.statespace.export.StateSpaceExporter#getFileExtensions()
	 */
	@Override
	public String[] getFileExtensions() {
		return new String[] { "nm", "tra" };
	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.statespace.StateSpaceExporter#setStateSpaceIndex(org.eclipse.emf.henshin.statespace.StateSpaceIndex)
	 */
	@Override
	public void setStateSpaceIndex(StateSpaceIndex index) {
		this.index = index;
	}
	
	private static Map<Rule,Double> getProbabilities(StateSpace stateSpace, Map<String,List<Rule>> probRules) {
		Map<Rule,Double> probs = new HashMap<Rule,Double>();
		for (List<Rule> rules : probRules.values()) {
			if (rules.size()==1) {
				probs.put(rules.get(0), 1.0);
			} else {
				for (int i=0; i<rules.size(); i++) {
					String p = stateSpace.getProperties().get("prob" + rules.get(i).getName() + (i+1));
					double d;
					try {
						d = Double.parseDouble(p);
					} catch (Throwable t) {
						d = 1;
					}
					probs.put(rules.get(i), d);
				}
			}
		}
		return probs;
	}
	
}
