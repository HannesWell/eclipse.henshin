package org.eclipse.emf.henshin.statespace.external.prism;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.henshin.model.Rule;
import org.eclipse.emf.henshin.statespace.State;
import org.eclipse.emf.henshin.statespace.StateSpace;
import org.eclipse.emf.henshin.statespace.StateSpaceExporter;
import org.eclipse.emf.henshin.statespace.StateSpaceIndex;
import org.eclipse.emf.henshin.statespace.Transition;

/**
 * Exporter for PRISM. This generates a MDP model.
 * @author Christian Krause
 */
public class MDPStateSpaceExporter implements StateSpaceExporter {

	private class Label {

		Transition tr;

		Label(Transition tr) {
			this.tr = tr;
		}

		@Override
		public int hashCode() {
			return tr.getRule().getName().hashCode() + tr.getMatch();
		}

		@Override
		public boolean equals(Object o) {
			Label l = (Label) o;
			return tr.getRule().getName().equals(l.tr.getRule().getName()) &&
					tr.getMatch()==l.tr.getMatch();
		}
	}

	private StateSpaceIndex index;

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.statespace.export.StateSpaceExporter#export(org.eclipse.emf.henshin.statespace.StateSpace, org.eclipse.emf.common.util.URI, org.eclipse.core.runtime.IProgressMonitor)
	 */
	@Override
	public void export(StateSpace stateSpace, URI uri, String parameters, IProgressMonitor monitor) throws IOException {

		int stateCount = stateSpace.getStates().size();
		monitor.beginTask("Exporting state space...", 2*stateCount);

		// Determine probabilistic rules:
		Map<String,List<Rule>> probRules = new LinkedHashMap<String,List<Rule>>();
		for (Rule rule : stateSpace.getRules()) {
			List<Rule> rules = probRules.get(rule.getName());
			if (rules==null) {
				rules = new ArrayList<Rule>();
				probRules.put(rule.getName(), rules);
			}
			rules.add(rule);
		}

		// Export to file...
		File file = new File(uri.toFileString());
		OutputStream out = new BufferedOutputStream(new FileOutputStream(file), 65536);
		OutputStreamWriter writer = new OutputStreamWriter(out);

		// Output the header:
		writer.write("// MDP model generated by Henshin on " + new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(new Date()) + "\n\n");
		writer.write("mdp\n\n");
		for (String ruleName : probRules.keySet()) {
			List<Rule> rules = probRules.get(ruleName);
			if (rules.size()>1) {
				for (int i=1; i<=rules.size(); i++)
					writer.write("const double prob" + ruleName + i + ";\n");				
			}
		}

		// Generate module specification:
		writer.write("\nmodule Transformation\n\n");
		writer.write("\ts : [0.." + stateSpace.getStates().size() + "];\n\n");

		// Output the transitions:
		for (State s : stateSpace.getStates()) {

			Map<Label,List<Transition>> trs = new LinkedHashMap<Label,List<Transition>>();
			for (Transition t : s.getOutgoing()) {
				Label l = new Label(t);
				List<Transition> x = trs.get(l);
				if (x==null) {
					x = new ArrayList<Transition>();
					trs.put(l, x);
				}
				x.add(t);
			}

			for (Label l : trs.keySet()) {

				// Output the transition:
				String name = l.tr.getRule().getName();
				writer.write("\t[" + name + "] s=" + s.getIndex() + " -> ");

				boolean first = true;
				for (Transition t : trs.get(l)) {
					List<Rule> rules = probRules.get(name);
					int index = rules.indexOf(t.getRule()) + 1;
					if (!first) {
						writer.write(" + ");
					}
					if (rules.size()>1) {
						writer.write("prob" + name + index + ":(s'=" + t.getTarget().getIndex() + ")");
					} else {
						writer.write("(s'=" + t.getTarget().getIndex() + ")");						
					}
					first = false;
				}
				writer.write(";\n");
			}
			
			// Update the monitor:
			monitor.worked(1);
			if (monitor.isCanceled()) {
				break;
			}

		}
		writer.write("\nendmodule\n\n");

		// Initial states
		writer.write("init\n\t");
		for (int i=0; i<stateSpace.getInitialStates().size(); i++) {
			writer.write("s=" + stateSpace.getInitialStates().get(i).getIndex());
			if (i<stateSpace.getInitialStates().size()-1) writer.write(" | ");
		}
		writer.write("\nendinit\n");

		if (parameters!=null) {
			try {
				String expanded = PRISMUtil.expandLabels(parameters, index, 
						new SubProgressMonitor(monitor, stateCount));
				writer.write("\n" + expanded + "\n");
			} catch (Exception e) {
				throw new IOException(e);
			}
		}

		// Finished:
		writer.close();
		if (!monitor.isCanceled()) {
			monitor.done();
		}

	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.statespace.export.StateSpaceExporter#getName()
	 */
	@Override
	public String getName() {
		return "PRISM MDP";
	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.statespace.export.StateSpaceExporter#getFileExtensions()
	 */
	@Override
	public String[] getFileExtensions() {
		return new String[] { "nm" };
	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.statespace.StateSpaceExporter#setStateSpaceIndex(org.eclipse.emf.henshin.statespace.StateSpaceIndex)
	 */
	@Override
	public void setStateSpaceIndex(StateSpaceIndex index) {
		this.index = index;
	}

}
