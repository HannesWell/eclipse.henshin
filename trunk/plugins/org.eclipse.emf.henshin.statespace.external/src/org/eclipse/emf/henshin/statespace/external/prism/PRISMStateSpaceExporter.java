package org.eclipse.emf.henshin.statespace.external.prism;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.henshin.model.Rule;
import org.eclipse.emf.henshin.statespace.State;
import org.eclipse.emf.henshin.statespace.StateSpace;
import org.eclipse.emf.henshin.statespace.StateSpacePlugin;
import org.eclipse.emf.henshin.statespace.Transition;
import org.eclipse.emf.henshin.statespace.export.StateSpaceExporter;
import org.eclipse.emf.henshin.statespace.util.StateSpaceProperties;

/**
 * Exporter for PRISM. This generates a CTMC model.
 * @author Christian Krause
 */
public class PRISMStateSpaceExporter implements StateSpaceExporter {

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.statespace.export.StateSpaceExporter#export(org.eclipse.emf.henshin.statespace.StateSpace, org.eclipse.emf.common.util.URI, org.eclipse.core.runtime.IProgressMonitor)
	 */
	@Override
	public void export(StateSpace stateSpace, URI uri, IProgressMonitor monitor) throws IOException {

		monitor.beginTask("Exporting state space...", stateSpace.getTransitionCount());

		// Export to file...
		File file = new File(uri.toFileString());
		OutputStream out = new BufferedOutputStream(new FileOutputStream(file), 65536);
		OutputStreamWriter writer = new OutputStreamWriter(out);
		
		// Output the header:
		writer.write("// CTMC model generated by Henshin on " + new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(new Date()) + "\n\n");
		writer.write("ctmc\n\n");
		for (Rule rule : stateSpace.getRules()) {
			int rate = StateSpaceProperties.getRate(stateSpace, rule);
			writer.write("const double " + getRateName(rule) + (rate>0 ? " = "+rate+";\n" : ";\n"));
		}
		
		// Make sure that there is exactly one initial state.
		if (stateSpace.getInitialStates().size()!=1) {
			StateSpacePlugin.INSTANCE.logError("PRISM format requires exactly one initial state!", null);
			if (stateSpace.getInitialStates().isEmpty()) throw new IOException();
		}
		
		// The states:
		int states = stateSpace.getStates().size();
		int initial = stateSpace.getInitialStates().get(0).getIndex();
		
		// Generate module specification:
		writer.write("\nmodule Transformation\n\n");
		writer.write("\ts : [0.." + states + "] init " + initial + ";\n\n");
		for (State s : stateSpace.getStates()) {
			for (Transition t : s.getOutgoing()) {
				
				// Ouput the transition:
				writer.write("\t[" + getRuleName(t.getRule())+ "] s=" + s.getIndex() + 
							  " -> " + getRateName(t.getRule()) + 
							  " : (s'=" + t.getTarget().getIndex() + ");\n");
				
				// Update the monitor:
				monitor.worked(1);
				if (monitor.isCanceled()) {
					break;
				}
			}
		}
		writer.write("\nendmodule\n");
		
		// Finished:
		writer.close();
		if (!monitor.isCanceled()) {
			monitor.done();
		}
		
	}
	
	/*
	 * Canonical name for rules.
	 */
	protected static String getRuleName(Rule rule) {
		return rule.getName().trim();
	}
	
	/*
	 * Canonical rate names.
	 */
	protected static String getRateName(Rule rule) {
		return "rate" + capitalize(getRuleName(rule));
	}

	/*
	 * Capitalize a string.
	 */
	protected static String capitalize(String string) {
		if (string==null || string.length()==0) return string;
		String first = string.substring(0,1).toUpperCase();
		if (string.length()==0) return first;
		else return first + string.substring(1);
	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.statespace.export.StateSpaceExporter#getName()
	 */
	@Override
	public String getName() {
		return "PRISM";
	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.emf.henshin.statespace.export.StateSpaceExporter#getFileExtensions()
	 */
	@Override
	public String[] getFileExtensions() {
		return new String[] { "sm" };
	}

}
